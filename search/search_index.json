{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".bs-sidebar { display: none; } $(\"div.col-md-3\").remove(); $(\"div.col-md-9\").attr(\"class\", \"col-md-12\"); BundleWrap documentation I want to learn BundleWrap! Should I use BundleWrap? If you run into a problem that is not answered in these docs, please find us on GitHub . We\u2019re happy to help! Should you already know your way around, just click on the part of your repo that you need help with: bundles/ mybundle/ bundle.py items.py metadata.py files/ template data/ hooks/ items/ libs/ .secrets.cfg groups.py nodes/ nodename.toml nodes.py requirements.txt","title":"<i class=\"fa fa-home\"></i>"},{"location":"guide/api/","text":"API While most users will interact with BundleWrap through the bw command line utility, you can also use it from your own code to extract data or further automate config management tasks. Even within BundleWrap itself (e.g. templates, libs, and hooks) you are often given repo and/or node objects to work with. Their methods and attributes are documented below. Some general notes on using BundleWrap's API: There can be an arbitrary amount of bundlewrap.repo.Repository objects per process. Repositories are read as needed and not re-read when something changes. Modifying files in a repo during the lifetime of the matching Repository object may result in undefined behavior. Example Here's a short example of how to use BundleWrap to get the uptime for a node. from bundlewrap.repo import Repository repo = Repository(\"/path/to/my/repo\") node = repo.get_node(\"mynode\") uptime = node.run(\"uptime\") print(uptime.stdout) Reference bundlewrap.repo.Repository(path) The starting point of any interaction with BundleWrap. An object of this class represents the repository at the given path. path can be a subpath of your repository (e.g., bundles/nginx/ ) and will internally be resolved to the root path of said repository. .branch The current git branch of this repo. None if not in a git repo. .clean Boolean indicating if there are uncommitted changes in git. None if not in a git repo. .groups A list of all groups in the repo (instances of bundlewrap.group.Group ) .nodes A list of all nodes in the repo (instances of bundlewrap.node.Node ) .revision The current git, hg or bzr revision of this repo. None if no SCM was detected. .get_group(group_name) Returns the Group object for the given name. .get_node(node_name) Returns the Node object with the given name. .nodes_in_all_groups(group_names) Returns a list of Node objects where every node is a member of every group name given. .nodes_in_any_group(group_names) Returns all Node objects that are a member of at least one of the given group names. .nodes_in_group(group_name) Returns a list of Node objects in the named group. bundlewrap.node.Node() A system managed by BundleWrap. .bundles A list of all bundles associated with this node (instances of bundlewrap.bundle.Bundle ) .groups A list of bundlewrap.group.Group objects this node belongs to .hostname The DNS name BundleWrap uses to connect to this node .items A list of items on this node (instances of subclasses of bundlewrap.items.Item ) .magic_number A large number derived from the node's name. This number is very likely to be unique for your entire repository. You can, for example, use this number to easily \"jitter\" cronjobs: '{} {} * * * root /my/script'.format( node.magic_number % 60, node.magic_number % 2 + 4, ) .metadata A dictionary of custom metadata, merged from information in nodes.py and groups.py .name The internal identifier for this node .download(remote_path, local_path) Downloads a file from the node. remote_path Which file to get from the node local_path Where to put the file .get_item(item_id) Get the Item object with the given ID (e.g. \"file:/etc/motd\"). .has_bundle(bundle_name) True if the node has a bundle with the given name. .has_any_bundle(bundle_names) True if the node has a bundle with any of the given names. .in_group(group_name) True if the node is in a group with the given name. .in_any_group(group_names) True if the node is in a group with any of the given names. .run(command, may_fail=False) Runs a command on the node. Returns an instance of bundlewrap.operations.RunResult . command What should be executed on the node may_fail If False , bundlewrap.exceptions.RemoteException will be raised if the command does not return 0. bundlewrap.exceptions.TransportException will be raised if there was a transport error while running the command, e.g. the SSH process died unexpectedly. .run_ipmitool(command) Runs a command on an ipmi interface. Returns an instance of bundlewrap.operations.RunResult . A command is a string of tokens which gets passed to ipmitool. The command will be split at whitespace characters and added to the commandline: # runs `ipmitool -H hostname -U username -P password power status` node.run_ipmitool('power status') .upload(local_path, remote_path, mode=None, owner=\"\", group=\"\") Uploads a file to the node. local_path Which file to upload remote_path Where to put the file on the target node mode File mode, e.g. \"0644\" owner Username of the file owner group Group name of the file group bundlewrap.group.Group A user-defined group of nodes. .name The name of this group .nodes A list of all nodes in this group (instances of bundlewrap.node.Node , includes subgroup members) bundlewrap.utils.Fault A Fault acts as a lazy stand-in object for the result of a given callback function. These objects are returned from the \"vault\" attached to Repository objects: >>> repo.vault.password_for(\"demo\") <bundlewrap.utils.Fault object at 0x10782b208> Only when the value property of a Fault is accessed or when the Fault is converted to a string, the callback function is executed. In the example above, this means that the password is only generated when it is really required (e.g. when used in a template). This is particularly useful when used in metadata in connection with secrets . Users will be able to generate metadata with Faults in it, even if they lack the required keys for the decryption operation represented by the Fault. The key will only be required for files etc. that actually use it. If a Fault cannot be resolved (e.g. for lack of the required key), BundleWrap can just skip the item using the Fault, while still allowing other items on the same node to be applied. Faults also support some rudimentary string operations such as appending a string or another Fault, as well as some string methods: >>> f = repo.vault.password_for(\"1\") + \":\" + repo.vault.password_for(\"2\") >>> f <bundlewrap.utils.Fault object at 0x10782b208> >>> f.value 'VOd5PC:JUgYUb' >>> f += \" \" >>> f.value 'VOd5PC:JUgYUb ' >>> f.strip().value 'VOd5PC:JUgYUb' >>> repo.vault.password_for(\"1\").format_into(\"Password: {}\").value 'Password: VOd5PC' >>> repo.vault.password_for(\"1\").b64encode().value 'Vk9kNVA=' >>> repo.vault.password_for(\"1\").as_htpasswd_entry(\"username\").value 'username:$apr1$8be694c7\u2026' These string methods are supported on Faults: format , lower , lstrip , replace , rstrip , strip , upper , zfill","title":"Python API"},{"location":"guide/api/#api","text":"While most users will interact with BundleWrap through the bw command line utility, you can also use it from your own code to extract data or further automate config management tasks. Even within BundleWrap itself (e.g. templates, libs, and hooks) you are often given repo and/or node objects to work with. Their methods and attributes are documented below. Some general notes on using BundleWrap's API: There can be an arbitrary amount of bundlewrap.repo.Repository objects per process. Repositories are read as needed and not re-read when something changes. Modifying files in a repo during the lifetime of the matching Repository object may result in undefined behavior.","title":"API"},{"location":"guide/api/#example","text":"Here's a short example of how to use BundleWrap to get the uptime for a node. from bundlewrap.repo import Repository repo = Repository(\"/path/to/my/repo\") node = repo.get_node(\"mynode\") uptime = node.run(\"uptime\") print(uptime.stdout)","title":"Example"},{"location":"guide/api/#reference","text":"","title":"Reference"},{"location":"guide/api/#bundlewrapreporepositorypath","text":"The starting point of any interaction with BundleWrap. An object of this class represents the repository at the given path. path can be a subpath of your repository (e.g., bundles/nginx/ ) and will internally be resolved to the root path of said repository. .branch The current git branch of this repo. None if not in a git repo. .clean Boolean indicating if there are uncommitted changes in git. None if not in a git repo. .groups A list of all groups in the repo (instances of bundlewrap.group.Group ) .nodes A list of all nodes in the repo (instances of bundlewrap.node.Node ) .revision The current git, hg or bzr revision of this repo. None if no SCM was detected. .get_group(group_name) Returns the Group object for the given name. .get_node(node_name) Returns the Node object with the given name. .nodes_in_all_groups(group_names) Returns a list of Node objects where every node is a member of every group name given. .nodes_in_any_group(group_names) Returns all Node objects that are a member of at least one of the given group names. .nodes_in_group(group_name) Returns a list of Node objects in the named group.","title":"bundlewrap.repo.Repository(path)"},{"location":"guide/api/#bundlewrapnodenode","text":"A system managed by BundleWrap. .bundles A list of all bundles associated with this node (instances of bundlewrap.bundle.Bundle ) .groups A list of bundlewrap.group.Group objects this node belongs to .hostname The DNS name BundleWrap uses to connect to this node .items A list of items on this node (instances of subclasses of bundlewrap.items.Item ) .magic_number A large number derived from the node's name. This number is very likely to be unique for your entire repository. You can, for example, use this number to easily \"jitter\" cronjobs: '{} {} * * * root /my/script'.format( node.magic_number % 60, node.magic_number % 2 + 4, ) .metadata A dictionary of custom metadata, merged from information in nodes.py and groups.py .name The internal identifier for this node .download(remote_path, local_path) Downloads a file from the node. remote_path Which file to get from the node local_path Where to put the file .get_item(item_id) Get the Item object with the given ID (e.g. \"file:/etc/motd\"). .has_bundle(bundle_name) True if the node has a bundle with the given name. .has_any_bundle(bundle_names) True if the node has a bundle with any of the given names. .in_group(group_name) True if the node is in a group with the given name. .in_any_group(group_names) True if the node is in a group with any of the given names. .run(command, may_fail=False) Runs a command on the node. Returns an instance of bundlewrap.operations.RunResult . command What should be executed on the node may_fail If False , bundlewrap.exceptions.RemoteException will be raised if the command does not return 0. bundlewrap.exceptions.TransportException will be raised if there was a transport error while running the command, e.g. the SSH process died unexpectedly. .run_ipmitool(command) Runs a command on an ipmi interface. Returns an instance of bundlewrap.operations.RunResult . A command is a string of tokens which gets passed to ipmitool. The command will be split at whitespace characters and added to the commandline: # runs `ipmitool -H hostname -U username -P password power status` node.run_ipmitool('power status') .upload(local_path, remote_path, mode=None, owner=\"\", group=\"\") Uploads a file to the node. local_path Which file to upload remote_path Where to put the file on the target node mode File mode, e.g. \"0644\" owner Username of the file owner group Group name of the file group","title":"bundlewrap.node.Node()"},{"location":"guide/api/#bundlewrapgroupgroup","text":"A user-defined group of nodes. .name The name of this group .nodes A list of all nodes in this group (instances of bundlewrap.node.Node , includes subgroup members)","title":"bundlewrap.group.Group"},{"location":"guide/api/#bundlewraputilsfault","text":"A Fault acts as a lazy stand-in object for the result of a given callback function. These objects are returned from the \"vault\" attached to Repository objects: >>> repo.vault.password_for(\"demo\") <bundlewrap.utils.Fault object at 0x10782b208> Only when the value property of a Fault is accessed or when the Fault is converted to a string, the callback function is executed. In the example above, this means that the password is only generated when it is really required (e.g. when used in a template). This is particularly useful when used in metadata in connection with secrets . Users will be able to generate metadata with Faults in it, even if they lack the required keys for the decryption operation represented by the Fault. The key will only be required for files etc. that actually use it. If a Fault cannot be resolved (e.g. for lack of the required key), BundleWrap can just skip the item using the Fault, while still allowing other items on the same node to be applied. Faults also support some rudimentary string operations such as appending a string or another Fault, as well as some string methods: >>> f = repo.vault.password_for(\"1\") + \":\" + repo.vault.password_for(\"2\") >>> f <bundlewrap.utils.Fault object at 0x10782b208> >>> f.value 'VOd5PC:JUgYUb' >>> f += \" \" >>> f.value 'VOd5PC:JUgYUb ' >>> f.strip().value 'VOd5PC:JUgYUb' >>> repo.vault.password_for(\"1\").format_into(\"Password: {}\").value 'Password: VOd5PC' >>> repo.vault.password_for(\"1\").b64encode().value 'Vk9kNVA=' >>> repo.vault.password_for(\"1\").as_htpasswd_entry(\"username\").value 'username:$apr1$8be694c7\u2026' These string methods are supported on Faults: format , lower , lstrip , replace , rstrip , strip , upper , zfill","title":"bundlewrap.utils.Fault"},{"location":"guide/cli/","text":"Command Line Interface The bw utility is BundleWrap's command line interface. This page is not meant as a complete reference. It provides a starting point to explore the various subcommands. If you're looking for details, --help is your friend. bw apply bw apply -i mynode The most important and most used part of BundleWrap, bw apply will apply your configuration to a set of nodes . By default, it operates in a non-interactive mode. When you're trying something new or are otherwise unsure of some changes, use the -i switch to have BundleWrap interactively ask before each change is made. bw run $ bw run mygroup \"uname -a\" Unsurprisingly, the run subcommand is used to run commands on nodes. As with most commands that accept node names, you can also give a group name or any combination of node and group names, separated by commas (without spaces, e.g. node1,group2,node3 ). A third option is to use a bundle selector like bundle:my_bundle . It will select all nodes with the named bundle . You can freely mix and match node names, group names, and bundle selectors. Negation is also possible for bundles and groups. !bundle:foo will add all nodes without the foo bundle, while !group:foo will add all nodes that aren't in the foo group. bw debug $ bw debug bundlewrap X.Y.Z interactive repository inspector > You can access the current repository as 'repo'. >>> len(repo.nodes) 121 This command will drop you into a Python shell with direct access to BundleWrap's API . Once you're familiar with it, it can be a very powerful tool. bw plot You'll need Graphviz installed on your machine for this to be useful. $ bw plot node mynode | dot -Tsvg -omynode.svg You won't be using this every day, but it's pretty cool. The above command will create an SVG file (you can open these in your browser) that shows the item dependency graph for the given node. You will see bundles as dashed rectangles, static dependencies (defined in BundleWrap itself) in green, auto-generated dependencies (calculated dynamically each time you run bw apply ) in blue and dependencies you defined yourself in red. It offers an interesting view into the internal complexities BundleWrap has to deal with when figuring out the order in which your items can be applied to your node. bw test $ bw test \u2713 node1 samba pkg_apt:samba \u2718 node1 samba file:/etc/samba/smb.conf [...] +----- traceback from worker ------ | | Traceback (most recent call last): | File \"bundlewrap/concurrency.py\", line 78, in _worker_process | return_value = target(*msg['args'], **msg['kwargs']) | File \"<string>\", line 378, in test | BundleError: file:/etc/samba/smb.conf from bundle 'samba' refers to missing file '/path/to/bundlewrap/repo/bundles/samba/files/smb.conf' | +---------------------------------- This command is meant to be run automatically like a test suite after every commit. It will try to catch any errors in your bundles and file templates by initializing every item for every node (but without touching the network).","title":"CLI"},{"location":"guide/cli/#command-line-interface","text":"The bw utility is BundleWrap's command line interface. This page is not meant as a complete reference. It provides a starting point to explore the various subcommands. If you're looking for details, --help is your friend.","title":"Command Line Interface"},{"location":"guide/cli/#bw-apply","text":"bw apply -i mynode The most important and most used part of BundleWrap, bw apply will apply your configuration to a set of nodes . By default, it operates in a non-interactive mode. When you're trying something new or are otherwise unsure of some changes, use the -i switch to have BundleWrap interactively ask before each change is made.","title":"bw apply"},{"location":"guide/cli/#bw-run","text":"$ bw run mygroup \"uname -a\" Unsurprisingly, the run subcommand is used to run commands on nodes. As with most commands that accept node names, you can also give a group name or any combination of node and group names, separated by commas (without spaces, e.g. node1,group2,node3 ). A third option is to use a bundle selector like bundle:my_bundle . It will select all nodes with the named bundle . You can freely mix and match node names, group names, and bundle selectors. Negation is also possible for bundles and groups. !bundle:foo will add all nodes without the foo bundle, while !group:foo will add all nodes that aren't in the foo group.","title":"bw run"},{"location":"guide/cli/#bw-debug","text":"$ bw debug bundlewrap X.Y.Z interactive repository inspector > You can access the current repository as 'repo'. >>> len(repo.nodes) 121 This command will drop you into a Python shell with direct access to BundleWrap's API . Once you're familiar with it, it can be a very powerful tool.","title":"bw debug"},{"location":"guide/cli/#bw-plot","text":"You'll need Graphviz installed on your machine for this to be useful. $ bw plot node mynode | dot -Tsvg -omynode.svg You won't be using this every day, but it's pretty cool. The above command will create an SVG file (you can open these in your browser) that shows the item dependency graph for the given node. You will see bundles as dashed rectangles, static dependencies (defined in BundleWrap itself) in green, auto-generated dependencies (calculated dynamically each time you run bw apply ) in blue and dependencies you defined yourself in red. It offers an interesting view into the internal complexities BundleWrap has to deal with when figuring out the order in which your items can be applied to your node.","title":"bw plot"},{"location":"guide/cli/#bw-test","text":"$ bw test \u2713 node1 samba pkg_apt:samba \u2718 node1 samba file:/etc/samba/smb.conf [...] +----- traceback from worker ------ | | Traceback (most recent call last): | File \"bundlewrap/concurrency.py\", line 78, in _worker_process | return_value = target(*msg['args'], **msg['kwargs']) | File \"<string>\", line 378, in test | BundleError: file:/etc/samba/smb.conf from bundle 'samba' refers to missing file '/path/to/bundlewrap/repo/bundles/samba/files/smb.conf' | +---------------------------------- This command is meant to be run automatically like a test suite after every commit. It will try to catch any errors in your bundles and file templates by initializing every item for every node (but without touching the network).","title":"bw test"},{"location":"guide/dev_item/","text":"Custom item types Step 0: Understand statedicts To represent supposed vs. actual state, BundleWrap uses statedicts. These are normal Python dictionaries with some restrictions: keys must be Unicode text every value must be of one of these simple data types: bool float int Unicode text None ...or a list/tuple containing only instances of one of the types above Additional information can be stored in statedicts by using keys that start with an underscore. You may only use this for caching purposes (e.g. storing rendered file template content while the \"real\" sdict information only contains a hash of this content). BundleWrap will ignore these keys and hide them from the user. The type restrictions noted above do not apply. Step 1: Create an item module Create a new file called /your/bundlewrap/repo/items/foo.py . You can use this as a template: from bundlewrap.items import Item class Foo(Item): \"\"\" A foo. \"\"\" BUNDLE_ATTRIBUTE_NAME = \"foo\" ITEM_ATTRIBUTES = { 'attribute': \"default value\", } ITEM_TYPE_NAME = \"foo\" REQUIRED_ATTRIBUTES = ['attribute'] @classmethod def block_concurrent(cls, node_os, node_os_version): \"\"\" Return a list of item types that cannot be applied in parallel with this item type. \"\"\" return [] def __repr__(self): return \"<Foo attribute:{}>\".format(self.attributes['attribute']) def cdict(self): \"\"\" Return a statedict that describes the target state of this item as configured in the repo (mnemonic: _c_dict for _config_ dict). Returning `None` instead means that the item should not exist. Implementing this method is optional. The default implementation uses the attributes as defined in the bundle. \"\"\" raise NotImplementedError def sdict(self): \"\"\" Return a statedict that describes the actual state of this item on the node (mnemonic: _s_dict for _state_ dict). Returning `None` instead means that the item does not exist on the node. For the item to validate as correct, the values for all keys in self.cdict() have to match this statedict. \"\"\" raise NotImplementedError def display_on_create(self, cdict): \"\"\" Given a cdict as implemented above, modify it to better suit interactive presentation when an item is created. If there are any when_creating attributes, they will be added to the cdict before it is passed to this method. Implementing this method is optional. \"\"\" return cdict def display_dicts(self, cdict, sdict, keys): \"\"\" Given cdict and sdict as implemented above, modify them to better suit interactive presentation. The keys parameter is a list of keys whose values differ between cdict and sdict. Implementing this method is optional. \"\"\" return (cdict, sdict, keys) def display_on_delete(self, sdict): \"\"\" Given an sdict as implemented above, modify it to better suit interactive presentation when an item is deleted. Implementing this method is optional. \"\"\" return sdict def fix(self, status): \"\"\" Do whatever is necessary to correct this item. The given ItemStatus object has the following useful information: status.keys_to_fix list of cdict keys that need fixing status.cdict cached copy of self.cdict() status.sdict cached copy of self.sdict() \"\"\" raise NotImplementedError Step 2: Define attributes BUNDLE_ATTRIBUTE_NAME is the name of the variable defined in a bundle module that holds the items of this type. If your bundle looks like this: foo = { [...] } ...then you should put BUNDLE_ATTRIBUTE_NAME = \"foo\" here. ITEM_ATTRIBUTES is a dictionary of the attributes users will be able to configure for your item. For files, that would be stuff like owner, group, and permissions. Every attribute (even if it's mandatory) needs a default value, None is totally acceptable: ITEM_ATTRIBUTES = {'attr1': \"default1\"} ITEM_TYPE_NAME sets the first part of an items ID. For the file items, this is \"file\". Therefore, file ID look this this: file:/path . The second part is the name a user assigns to your item in a bundle. Example: ITEM_TYPE_NAME = \"foo\" REQUIRED_ATTRIBUTES is a list of attribute names that must be set on each item of this type. If BundleWrap encounters an item without all these attributes during bundle inspection, an exception will be raised. Example: REQUIRED_ATTRIBUTES = ['attr1', 'attr2'] Step 3: Implement methods You should probably start with sdict() . Use self.run(\"command\") to run shell commands on the current node and check the stdout property of the returned object. The only other method you have to implement is fix . It doesn't have to return anything and just uses self.run() to fix the item. To do this efficiently, it may use the provided parameters indicating which keys differ between the should-be sdict and the actual one. Both sdicts are also provided in case you need to know their values. block_concurrent() must return a list of item types (e.g. ['pkg_apt'] ) that cannot be applied in parallel with this type of item. May include this very item type itself. For most items this is not an issue (e.g. creating multiple files at the same time), but some types of items have to be applied sequentially (e.g. package managers usually employ locks to ensure only one package is installed at a time). If you're having trouble, try looking at the source code for the items that come with BundleWrap . The pkg_* items are pretty simple and easy to understand while files is the most complex to date. Or just drop by on IRC or GitHub , we're glad to help.","title":"Custom items"},{"location":"guide/dev_item/#custom-item-types","text":"","title":"Custom item types"},{"location":"guide/dev_item/#step-0-understand-statedicts","text":"To represent supposed vs. actual state, BundleWrap uses statedicts. These are normal Python dictionaries with some restrictions: keys must be Unicode text every value must be of one of these simple data types: bool float int Unicode text None ...or a list/tuple containing only instances of one of the types above Additional information can be stored in statedicts by using keys that start with an underscore. You may only use this for caching purposes (e.g. storing rendered file template content while the \"real\" sdict information only contains a hash of this content). BundleWrap will ignore these keys and hide them from the user. The type restrictions noted above do not apply.","title":"Step 0: Understand statedicts"},{"location":"guide/dev_item/#step-1-create-an-item-module","text":"Create a new file called /your/bundlewrap/repo/items/foo.py . You can use this as a template: from bundlewrap.items import Item class Foo(Item): \"\"\" A foo. \"\"\" BUNDLE_ATTRIBUTE_NAME = \"foo\" ITEM_ATTRIBUTES = { 'attribute': \"default value\", } ITEM_TYPE_NAME = \"foo\" REQUIRED_ATTRIBUTES = ['attribute'] @classmethod def block_concurrent(cls, node_os, node_os_version): \"\"\" Return a list of item types that cannot be applied in parallel with this item type. \"\"\" return [] def __repr__(self): return \"<Foo attribute:{}>\".format(self.attributes['attribute']) def cdict(self): \"\"\" Return a statedict that describes the target state of this item as configured in the repo (mnemonic: _c_dict for _config_ dict). Returning `None` instead means that the item should not exist. Implementing this method is optional. The default implementation uses the attributes as defined in the bundle. \"\"\" raise NotImplementedError def sdict(self): \"\"\" Return a statedict that describes the actual state of this item on the node (mnemonic: _s_dict for _state_ dict). Returning `None` instead means that the item does not exist on the node. For the item to validate as correct, the values for all keys in self.cdict() have to match this statedict. \"\"\" raise NotImplementedError def display_on_create(self, cdict): \"\"\" Given a cdict as implemented above, modify it to better suit interactive presentation when an item is created. If there are any when_creating attributes, they will be added to the cdict before it is passed to this method. Implementing this method is optional. \"\"\" return cdict def display_dicts(self, cdict, sdict, keys): \"\"\" Given cdict and sdict as implemented above, modify them to better suit interactive presentation. The keys parameter is a list of keys whose values differ between cdict and sdict. Implementing this method is optional. \"\"\" return (cdict, sdict, keys) def display_on_delete(self, sdict): \"\"\" Given an sdict as implemented above, modify it to better suit interactive presentation when an item is deleted. Implementing this method is optional. \"\"\" return sdict def fix(self, status): \"\"\" Do whatever is necessary to correct this item. The given ItemStatus object has the following useful information: status.keys_to_fix list of cdict keys that need fixing status.cdict cached copy of self.cdict() status.sdict cached copy of self.sdict() \"\"\" raise NotImplementedError","title":"Step 1: Create an item module"},{"location":"guide/dev_item/#step-2-define-attributes","text":"BUNDLE_ATTRIBUTE_NAME is the name of the variable defined in a bundle module that holds the items of this type. If your bundle looks like this: foo = { [...] } ...then you should put BUNDLE_ATTRIBUTE_NAME = \"foo\" here. ITEM_ATTRIBUTES is a dictionary of the attributes users will be able to configure for your item. For files, that would be stuff like owner, group, and permissions. Every attribute (even if it's mandatory) needs a default value, None is totally acceptable: ITEM_ATTRIBUTES = {'attr1': \"default1\"} ITEM_TYPE_NAME sets the first part of an items ID. For the file items, this is \"file\". Therefore, file ID look this this: file:/path . The second part is the name a user assigns to your item in a bundle. Example: ITEM_TYPE_NAME = \"foo\" REQUIRED_ATTRIBUTES is a list of attribute names that must be set on each item of this type. If BundleWrap encounters an item without all these attributes during bundle inspection, an exception will be raised. Example: REQUIRED_ATTRIBUTES = ['attr1', 'attr2']","title":"Step 2: Define attributes"},{"location":"guide/dev_item/#step-3-implement-methods","text":"You should probably start with sdict() . Use self.run(\"command\") to run shell commands on the current node and check the stdout property of the returned object. The only other method you have to implement is fix . It doesn't have to return anything and just uses self.run() to fix the item. To do this efficiently, it may use the provided parameters indicating which keys differ between the should-be sdict and the actual one. Both sdicts are also provided in case you need to know their values. block_concurrent() must return a list of item types (e.g. ['pkg_apt'] ) that cannot be applied in parallel with this type of item. May include this very item type itself. For most items this is not an issue (e.g. creating multiple files at the same time), but some types of items have to be applied sequentially (e.g. package managers usually employ locks to ensure only one package is installed at a time). If you're having trouble, try looking at the source code for the items that come with BundleWrap . The pkg_* items are pretty simple and easy to understand while files is the most complex to date. Or just drop by on IRC or GitHub , we're glad to help.","title":"Step 3: Implement methods"},{"location":"guide/env/","text":"Environment Variables BW_ADD_HOST_KEYS As BundleWrap uses OpenSSH to connect to hosts, host key checking is involved. By default, strict host key checking is activated. This might not be suitable for your setup. You can set this variable to 1 to cause BundleWrap to set the OpenSSH option StrictHostKeyChecking=no . You can also use bw -a ... to achieve the same effect. BW_COLORS Colors are enabled by default. Setting this variable to 0 tells BundleWrap to never use any ANSI color escape sequences. BW_DEBUG_LOG_DIR Set this to an existing directory path to have BundleWrap write debug logs there (even when you're running bw without --debug ). Debug logs are verbose and BundleWrap does not rotate them for you. Putting them on a tmpfs or ramdisk will save your SSD and get rid of old logs every time you reboot your machine. BW_GIT_DEPLOY_CACHE Optional cache directory for git_deploy items. BW_HARDLOCK_EXPIRY Hard locks are automatically ignored after some time. By default, it's \"8h\" . You can use this variable to override that default. BW_IDENTITY When BundleWrap locks a node, it stores a short description about \"you\". By default, this is the string $USER@$HOSTNAME , e.g. john@mymachine . You can use BW_IDENTITY to specify a custom string. (No variables will be evaluated in user supplied strings.) BW_ITEM_WORKERS and BW_NODE_WORKERS BundleWrap attempts to parallelize work. These two options specify the number of nodes and items, respectively, which will be handled concurrently. To be more precise, when setting BW_NODE_WORKERS=8 and BW_ITEM_WORKERS=2 , BundleWrap will work on eight nodes in parallel, each handling two items in parallel. You can also use the command line options -p and -P , e.g. bw apply -p ... -P ... ... , to achieve the same effect. Command line arguments override environment variables. There is no single default for these values. For example, when running bw apply , four nodes are being handled by default. However, when running bw test , only one node will be tested by default. BW_NODE_WORKERS and BW_ITEM_WORKERS apply to all these operations. Note that you should not set these variables to very high values. First, it can cause high memory consumption on your machine. Second, not all SSH servers can handle massive parallelism. Please refer to your OpenSSH documentation on how to tune your servers for these situations. BW_MAX_METADATA_ITERATIONS Sets the limit of how often metadata reactors will be run for a node before BundleWrap calls it a loop and terminates with an exception. Defaults to 1000 . BW_REPO_PATH Set this to a path pointing to your BundleWrap repository. If unset, the current working directory is used. Can be overridden with bw --repository PATH . Keep in mind that bw will also look for a repository in all parent directories until it finds one. BW_SOFTLOCK_EXPIRY Soft locks are automatically removed from nodes after some time. By default, it's \"8h\" . You can use this variable to override that default. BW_SSH_ARGS Extra arguments to include in every call to ssh BundleWrap makes. Set this to \"-F ~/.ssh/otherconf\" to use a different SSH config with BundleWrap. Defaults to \"\" . BW_SCP_ARGS Extra arguments to include in every call to scp BundleWrap makes. Defaults to the value of BW_SSH_ARGS . BW_TABLE_STYLE By default, BundleWrap uses Unicode box-drawing characters at various points in its output. Setting this env var to one of the following values changes that behavior: ascii use only simple ASCII characters to render tables (useful if your font doesn't properly align box-drawing characters) csv comma-separated values grep make output more grep - and cut -friendly BW_VAULT_DUMMY_MODE Setting this to 1 will make repo.vault return dummy values for every secret . This is useful for running bw test on a CI server that you don't want to trust with your .secrets.cfg .","title":"Environment Variables"},{"location":"guide/env/#environment-variables","text":"","title":"Environment Variables"},{"location":"guide/env/#bw_add_host_keys","text":"As BundleWrap uses OpenSSH to connect to hosts, host key checking is involved. By default, strict host key checking is activated. This might not be suitable for your setup. You can set this variable to 1 to cause BundleWrap to set the OpenSSH option StrictHostKeyChecking=no . You can also use bw -a ... to achieve the same effect.","title":"BW_ADD_HOST_KEYS"},{"location":"guide/env/#bw_colors","text":"Colors are enabled by default. Setting this variable to 0 tells BundleWrap to never use any ANSI color escape sequences.","title":"BW_COLORS"},{"location":"guide/env/#bw_debug_log_dir","text":"Set this to an existing directory path to have BundleWrap write debug logs there (even when you're running bw without --debug ). Debug logs are verbose and BundleWrap does not rotate them for you. Putting them on a tmpfs or ramdisk will save your SSD and get rid of old logs every time you reboot your machine.","title":"BW_DEBUG_LOG_DIR"},{"location":"guide/env/#bw_git_deploy_cache","text":"Optional cache directory for git_deploy items.","title":"BW_GIT_DEPLOY_CACHE"},{"location":"guide/env/#bw_hardlock_expiry","text":"Hard locks are automatically ignored after some time. By default, it's \"8h\" . You can use this variable to override that default.","title":"BW_HARDLOCK_EXPIRY"},{"location":"guide/env/#bw_identity","text":"When BundleWrap locks a node, it stores a short description about \"you\". By default, this is the string $USER@$HOSTNAME , e.g. john@mymachine . You can use BW_IDENTITY to specify a custom string. (No variables will be evaluated in user supplied strings.)","title":"BW_IDENTITY"},{"location":"guide/env/#bw_item_workers-and-bw_node_workers","text":"BundleWrap attempts to parallelize work. These two options specify the number of nodes and items, respectively, which will be handled concurrently. To be more precise, when setting BW_NODE_WORKERS=8 and BW_ITEM_WORKERS=2 , BundleWrap will work on eight nodes in parallel, each handling two items in parallel. You can also use the command line options -p and -P , e.g. bw apply -p ... -P ... ... , to achieve the same effect. Command line arguments override environment variables. There is no single default for these values. For example, when running bw apply , four nodes are being handled by default. However, when running bw test , only one node will be tested by default. BW_NODE_WORKERS and BW_ITEM_WORKERS apply to all these operations. Note that you should not set these variables to very high values. First, it can cause high memory consumption on your machine. Second, not all SSH servers can handle massive parallelism. Please refer to your OpenSSH documentation on how to tune your servers for these situations.","title":"BW_ITEM_WORKERS and BW_NODE_WORKERS"},{"location":"guide/env/#bw_max_metadata_iterations","text":"Sets the limit of how often metadata reactors will be run for a node before BundleWrap calls it a loop and terminates with an exception. Defaults to 1000 .","title":"BW_MAX_METADATA_ITERATIONS"},{"location":"guide/env/#bw_repo_path","text":"Set this to a path pointing to your BundleWrap repository. If unset, the current working directory is used. Can be overridden with bw --repository PATH . Keep in mind that bw will also look for a repository in all parent directories until it finds one.","title":"BW_REPO_PATH"},{"location":"guide/env/#bw_softlock_expiry","text":"Soft locks are automatically removed from nodes after some time. By default, it's \"8h\" . You can use this variable to override that default.","title":"BW_SOFTLOCK_EXPIRY"},{"location":"guide/env/#bw_ssh_args","text":"Extra arguments to include in every call to ssh BundleWrap makes. Set this to \"-F ~/.ssh/otherconf\" to use a different SSH config with BundleWrap. Defaults to \"\" .","title":"BW_SSH_ARGS"},{"location":"guide/env/#bw_scp_args","text":"Extra arguments to include in every call to scp BundleWrap makes. Defaults to the value of BW_SSH_ARGS .","title":"BW_SCP_ARGS"},{"location":"guide/env/#bw_table_style","text":"By default, BundleWrap uses Unicode box-drawing characters at various points in its output. Setting this env var to one of the following values changes that behavior: ascii use only simple ASCII characters to render tables (useful if your font doesn't properly align box-drawing characters) csv comma-separated values grep make output more grep - and cut -friendly","title":"BW_TABLE_STYLE"},{"location":"guide/env/#bw_vault_dummy_mode","text":"Setting this to 1 will make repo.vault return dummy values for every secret . This is useful for running bw test on a CI server that you don't want to trust with your .secrets.cfg .","title":"BW_VAULT_DUMMY_MODE"},{"location":"guide/installation/","text":"Installation You may need to install pip first. This can be accomplished through your distribution's package manager, e.g.: aptitude install python-pip or the manual instructions . Using pip It's as simple as: pip install bundlewrap Note that you need at least Python 2.7 to run BundleWrap. Python 3 is supported as long as it's >= 3.3. From git This type of install will give you the very latest (and thus possibly broken) bleeding edge version of BundleWrap. You should only use this if you know what you're doing. The instructions below are for installing on Ubuntu Server 12.10 (Quantal), but should also work for other versions of Ubuntu/Debian. If you're on some other distro, you will obviously have to adjust the package install commands. The instructions assume you have root privileges. Install basic requirements: aptitude install build-essential git python-dev python-pip Clone the GitHub repository: cd /opt git clone https://github.com/bundlewrap/bundlewrap.git Use pip install -e to install in \"development mode\": pip install -e /opt/bundlewrap You can now try running the bw command line utility: bw --help That's it. To update your install, just pull the git repository and have setup.py` check for new dependencies: cd /opt/bundlewrap git pull python setup.py develop Requirements for managed systems While the following list might appear long, even very minimal systems should provide everything that's needed. apt-get (only used with pkg_apt items) cat chmod chown dconf (only used with dconf items) dpkg (only used with pkg_apt items) echo file find grep groupadd groupmod id initctl (only used with svc_upstart items) mkdir mv pacman (only used with pkg_pacman items) pamac (only used with pkg_pamac items) rm sftp-enabled SSH server (your home directory must be writable) sudo sha1sum stat systemctl (only used with svc_systemd items) tar (only used with git_deploy items) useradd usermod zfs and zpool (only used with zfs_dataset and zfs_pool items) Additionally, you need to pre-configure your SSH client so that it can connect to your nodes without having to type a password (including sudo on the node, which also must not have the requiretty option set).","title":"Installation"},{"location":"guide/installation/#installation","text":"You may need to install pip first. This can be accomplished through your distribution's package manager, e.g.: aptitude install python-pip or the manual instructions .","title":"Installation"},{"location":"guide/installation/#using-pip","text":"It's as simple as: pip install bundlewrap Note that you need at least Python 2.7 to run BundleWrap. Python 3 is supported as long as it's >= 3.3.","title":"Using pip"},{"location":"guide/installation/#from-git","text":"This type of install will give you the very latest (and thus possibly broken) bleeding edge version of BundleWrap. You should only use this if you know what you're doing. The instructions below are for installing on Ubuntu Server 12.10 (Quantal), but should also work for other versions of Ubuntu/Debian. If you're on some other distro, you will obviously have to adjust the package install commands. The instructions assume you have root privileges. Install basic requirements: aptitude install build-essential git python-dev python-pip Clone the GitHub repository: cd /opt git clone https://github.com/bundlewrap/bundlewrap.git Use pip install -e to install in \"development mode\": pip install -e /opt/bundlewrap You can now try running the bw command line utility: bw --help That's it. To update your install, just pull the git repository and have setup.py` check for new dependencies: cd /opt/bundlewrap git pull python setup.py develop","title":"From git"},{"location":"guide/installation/#requirements-for-managed-systems","text":"While the following list might appear long, even very minimal systems should provide everything that's needed. apt-get (only used with pkg_apt items) cat chmod chown dconf (only used with dconf items) dpkg (only used with pkg_apt items) echo file find grep groupadd groupmod id initctl (only used with svc_upstart items) mkdir mv pacman (only used with pkg_pacman items) pamac (only used with pkg_pamac items) rm sftp-enabled SSH server (your home directory must be writable) sudo sha1sum stat systemctl (only used with svc_systemd items) tar (only used with git_deploy items) useradd usermod zfs and zpool (only used with zfs_dataset and zfs_pool items) Additionally, you need to pre-configure your SSH client so that it can connect to your nodes without having to type a password (including sudo on the node, which also must not have the requiretty option set).","title":"Requirements for managed systems"},{"location":"guide/item_file_templates/","text":"Writing file templates BundleWrap can use Mako or Jinja2 for file templating. This enables you to dynamically construct your config files. Templates reside in the files subdirectory of a bundle and are bound to a file item using the source attribute . This page explains how to get started with Mako. The most basic example would be: Hello, this is ${node.name}! After template rendering, it would look like this: Hello, this is myexamplenodename! As you can see, ${...} can be used to insert the value of a context variable into the rendered file. By default, you have access to two variables in every template: node and repo . They are bundlewrap.node.Node and bundlewrap.repo.Repository objects, respectively. You can learn more about the attributes and methods of these objects in the API docs , but here are a few examples: Examples inserts the DNS hostname of the current node ${node.hostname} a list of all nodes in your repo % for node in repo.nodes: ${node.name} % endfor make exceptions for certain nodes % if node.name == \"node1\": option = foo % elif node.name in (\"node2\", \"node3\"): option = bar % else: option = baz % endif check for group membership % if node.in_group(\"sparkle\"): enable_sparkles = 1 % endif check for membership in any of several groups % if node.in_any_group((\"sparkle\", \"shiny\")): enable_fancy = 1 % endif check for bundle % if node.has_bundle(\"sparkle\"): enable_sparkles = 1 % endif check for any of several bundles % if node.has_any_bundle((\"sparkle\", \"shiny\")): enable_fancy = 1 % endif list all nodes in a group % for gnode in repo.get_group(\"mygroup\").nodes: ${gnode.name} % endfor Working with node metadata Quite often you will attach custom metadata to your nodes in nodes.py , e.g.: nodes = { \"node1\": { \"metadata\": { \"interfaces\": { \"eth0\": \"10.1.1.47\", \"eth1\": \"10.1.2.47\", }, }, }, } You can easily access this information in templates: % for interface, ip in sorted(node.metadata[\"interfaces\"].items()): interface ${interface} ip = ${ip} % endfor This template will render to: interface eth0 ip = 10.1.1.47 interface eth1 ip = 10.1.2.47","title":"File templates"},{"location":"guide/item_file_templates/#writing-file-templates","text":"BundleWrap can use Mako or Jinja2 for file templating. This enables you to dynamically construct your config files. Templates reside in the files subdirectory of a bundle and are bound to a file item using the source attribute . This page explains how to get started with Mako. The most basic example would be: Hello, this is ${node.name}! After template rendering, it would look like this: Hello, this is myexamplenodename! As you can see, ${...} can be used to insert the value of a context variable into the rendered file. By default, you have access to two variables in every template: node and repo . They are bundlewrap.node.Node and bundlewrap.repo.Repository objects, respectively. You can learn more about the attributes and methods of these objects in the API docs , but here are a few examples:","title":"Writing file templates"},{"location":"guide/item_file_templates/#examples","text":"inserts the DNS hostname of the current node ${node.hostname} a list of all nodes in your repo % for node in repo.nodes: ${node.name} % endfor make exceptions for certain nodes % if node.name == \"node1\": option = foo % elif node.name in (\"node2\", \"node3\"): option = bar % else: option = baz % endif check for group membership % if node.in_group(\"sparkle\"): enable_sparkles = 1 % endif check for membership in any of several groups % if node.in_any_group((\"sparkle\", \"shiny\")): enable_fancy = 1 % endif check for bundle % if node.has_bundle(\"sparkle\"): enable_sparkles = 1 % endif check for any of several bundles % if node.has_any_bundle((\"sparkle\", \"shiny\")): enable_fancy = 1 % endif list all nodes in a group % for gnode in repo.get_group(\"mygroup\").nodes: ${gnode.name} % endfor","title":"Examples"},{"location":"guide/item_file_templates/#working-with-node-metadata","text":"Quite often you will attach custom metadata to your nodes in nodes.py , e.g.: nodes = { \"node1\": { \"metadata\": { \"interfaces\": { \"eth0\": \"10.1.1.47\", \"eth1\": \"10.1.2.47\", }, }, }, } You can easily access this information in templates: % for interface, ip in sorted(node.metadata[\"interfaces\"].items()): interface ${interface} ip = ${ip} % endfor This template will render to: interface eth0 ip = 10.1.1.47 interface eth1 ip = 10.1.2.47","title":"Working with node metadata"},{"location":"guide/kubernetes/","text":"Kubernetes Support for Kubernetes is experimental at this time. Backwards-incompatible changes may happen at any time. To manage a Kubernetes cluster with BundleWrap, you first need to set up a kubectl context that works with the cluster. If you're running on Google Kubernetes Engine for example, this can be accomplished with: gcloud auth login gcloud container clusters get-credentials your-cluster --zone your-zone --project your-project You also need to make sure context names are the same on your teammates' machines. Setting up a node Each Kubernetes cluster you manage becomes a node. Here is an example nodes.py : nodes = { \"my-cluster\": { 'os': 'kubernetes', 'bundles': [\"my-app\"], 'kubectl_context': \"my-context\", }, } Kubernetes bundles You can then proceed to write bundles as with regular nodes, but using the k8s_ items : k8s_namespaces = { \"my-app\": {}, } k8s_deployments = { \"my-app/my-deployment\": { 'manifest': { \"spec\": { \"selector\": { \"matchLabels\": { \"app\": \"nginx\", }, }, \"replicas\": 2, \"template\": { \"metadata\": { \"labels\": { \"app\": \"nginx\", }, }, \"spec\": { \"containers\": [ { \"name\": \"nginx\", \"image\": \"nginx:latest\", \"ports\": [ {\"containerPort\": 80}, ] }, ], }, }, }, }, }, } All item names (except namespaces themselves) must be prefixed with the name of a namespace and a forward slash / . Note that BundleWrap will include defaults for the Kind and metadata/name keys, but you can override them if you must. Alternatively, you can keep your resource definitions in manifest files: k8s_namespaces = { \"my-app\": {}, } k8s_deployments = { \"my-app/my-deployment\": { 'manifest_file': \"my_deployment.yaml\", }, } BundleWrap will then look for my_deployment.yaml in bundles/<bundle>/manifests/ . You can also use templating in these files.","title":"Kubernetes"},{"location":"guide/kubernetes/#kubernetes","text":"Support for Kubernetes is experimental at this time. Backwards-incompatible changes may happen at any time. To manage a Kubernetes cluster with BundleWrap, you first need to set up a kubectl context that works with the cluster. If you're running on Google Kubernetes Engine for example, this can be accomplished with: gcloud auth login gcloud container clusters get-credentials your-cluster --zone your-zone --project your-project You also need to make sure context names are the same on your teammates' machines.","title":"Kubernetes"},{"location":"guide/kubernetes/#setting-up-a-node","text":"Each Kubernetes cluster you manage becomes a node. Here is an example nodes.py : nodes = { \"my-cluster\": { 'os': 'kubernetes', 'bundles': [\"my-app\"], 'kubectl_context': \"my-context\", }, }","title":"Setting up a node"},{"location":"guide/kubernetes/#kubernetes-bundles","text":"You can then proceed to write bundles as with regular nodes, but using the k8s_ items : k8s_namespaces = { \"my-app\": {}, } k8s_deployments = { \"my-app/my-deployment\": { 'manifest': { \"spec\": { \"selector\": { \"matchLabels\": { \"app\": \"nginx\", }, }, \"replicas\": 2, \"template\": { \"metadata\": { \"labels\": { \"app\": \"nginx\", }, }, \"spec\": { \"containers\": [ { \"name\": \"nginx\", \"image\": \"nginx:latest\", \"ports\": [ {\"containerPort\": 80}, ] }, ], }, }, }, }, }, } All item names (except namespaces themselves) must be prefixed with the name of a namespace and a forward slash / . Note that BundleWrap will include defaults for the Kind and metadata/name keys, but you can override them if you must. Alternatively, you can keep your resource definitions in manifest files: k8s_namespaces = { \"my-app\": {}, } k8s_deployments = { \"my-app/my-deployment\": { 'manifest_file': \"my_deployment.yaml\", }, } BundleWrap will then look for my_deployment.yaml in bundles/<bundle>/manifests/ . You can also use templating in these files.","title":"Kubernetes bundles"},{"location":"guide/locks/","text":"Locking BundleWrap's decentralized nature makes it necessary to coordinate actions between users of a shared repository. Locking is an important part of collaborating using BundleWrap. Hard locks Since very early in the history of BundleWrap, what we call \"hard locks\" were used to prevent multiple users from using bw apply on the same node at the same time. When BundleWrap finds a hard lock on a node in interactive mode, it will display information about who acquired the lock (and when) and will ask whether to ignore the lock or abort the process. In non-interactive mode, the operation is always cancelled for the node in question unless --force is used. Soft locks Many teams these days are using a workflow based on pull requests. A common problem here is that changes from a feature branch might already have been applied to a set of nodes, while the master branch is still lacking these changes. While the pull request is open and waiting for review, other users might rightly use the master branch to apply to all nodes, reverting changes made by the feature branch. This can be a major nuisance. As of version 2.6.0, BundleWrap provides \"soft locks\" to prevent this. The author of a feature branch can now lock the node so only they can use bw apply on it: $ bw lock add node1 \u2713 node1 locked with ID B9JS (expires in 8h) This will prevent all other users from changing any items on the node for the next 8 hours. BundleWrap will tell users apart by their BW_IDENTITY . Now say someone else is reviewing the pull request and wants to use bw apply , while still keeping others out and the original author in. This can be done by simply locking the node again as the reviewer. Nodes can have many soft locks. Soft locks act as an exemption from a general ban on changing items that goes into effect as soon as one or more soft locks are present on the node. Of course, if no soft locks are present, anyone can change any item. You can list all soft locks on a node with: $ bw lock show node1 i node1 ID Created Expires User Items Comment \u203a node1 Y1KD 2016-05-25 21:30:25 2016-05-26 05:30:25 alice * locks are awesome \u203a node1 B9JS 2016-05-24 13:10:11 2016-05-27 08:10:11 bob * me too Note that each lock is identified by a case-insensitive 4-character ID that can be used to remove the lock: $ bw lock remove node1 y1kd \u2713 node1 lock Y1KD removed Expired locks are automatically and silently purged whenever BundleWrap has the opportunity. Be sure to check out bw lock add --help for how to customize expiration time, add a short comment explaining the reason for the lock, or lock only certain items. Using bw apply on a soft locked node is not an error and affected items will simply be skipped. Locking non-UNIX nodes Most of the time, BundleWrap assumes that your target system is a UNIX-like operating system. It then stores locks as files in the node's local file system ( /var/lib/bundlewrap by default). BundleWrap supports managing non-UNIX nodes, too, such as Kubernetes. You can also write your own custom item types to manage hardware. In those situations, BundleWrap has no place to store lock files. You can solve this by designating another regular UNIX node as a \"locking node\": nodes['my.k8s.cluster'] = { 'locking_node': 'my.openbsd.box', 'os': 'kubernetes', 'metadata': { ... }, } my.openbsd.box is the name of another regular node, which must be managed by BundleWrap. You can now use all the usual locking mechanisms when working with my.k8s.cluster and its locks will be stored on my.openbsd.box . (They will, of course, not conflict with regular locks for my.openbsd.box .) A locking node can host locks for as many other nodes as you wish.","title":"Locking"},{"location":"guide/locks/#locking","text":"BundleWrap's decentralized nature makes it necessary to coordinate actions between users of a shared repository. Locking is an important part of collaborating using BundleWrap.","title":"Locking"},{"location":"guide/locks/#hard-locks","text":"Since very early in the history of BundleWrap, what we call \"hard locks\" were used to prevent multiple users from using bw apply on the same node at the same time. When BundleWrap finds a hard lock on a node in interactive mode, it will display information about who acquired the lock (and when) and will ask whether to ignore the lock or abort the process. In non-interactive mode, the operation is always cancelled for the node in question unless --force is used.","title":"Hard locks"},{"location":"guide/locks/#soft-locks","text":"Many teams these days are using a workflow based on pull requests. A common problem here is that changes from a feature branch might already have been applied to a set of nodes, while the master branch is still lacking these changes. While the pull request is open and waiting for review, other users might rightly use the master branch to apply to all nodes, reverting changes made by the feature branch. This can be a major nuisance. As of version 2.6.0, BundleWrap provides \"soft locks\" to prevent this. The author of a feature branch can now lock the node so only they can use bw apply on it: $ bw lock add node1 \u2713 node1 locked with ID B9JS (expires in 8h) This will prevent all other users from changing any items on the node for the next 8 hours. BundleWrap will tell users apart by their BW_IDENTITY . Now say someone else is reviewing the pull request and wants to use bw apply , while still keeping others out and the original author in. This can be done by simply locking the node again as the reviewer. Nodes can have many soft locks. Soft locks act as an exemption from a general ban on changing items that goes into effect as soon as one or more soft locks are present on the node. Of course, if no soft locks are present, anyone can change any item. You can list all soft locks on a node with: $ bw lock show node1 i node1 ID Created Expires User Items Comment \u203a node1 Y1KD 2016-05-25 21:30:25 2016-05-26 05:30:25 alice * locks are awesome \u203a node1 B9JS 2016-05-24 13:10:11 2016-05-27 08:10:11 bob * me too Note that each lock is identified by a case-insensitive 4-character ID that can be used to remove the lock: $ bw lock remove node1 y1kd \u2713 node1 lock Y1KD removed Expired locks are automatically and silently purged whenever BundleWrap has the opportunity. Be sure to check out bw lock add --help for how to customize expiration time, add a short comment explaining the reason for the lock, or lock only certain items. Using bw apply on a soft locked node is not an error and affected items will simply be skipped.","title":"Soft locks"},{"location":"guide/locks/#locking-non-unix-nodes","text":"Most of the time, BundleWrap assumes that your target system is a UNIX-like operating system. It then stores locks as files in the node's local file system ( /var/lib/bundlewrap by default). BundleWrap supports managing non-UNIX nodes, too, such as Kubernetes. You can also write your own custom item types to manage hardware. In those situations, BundleWrap has no place to store lock files. You can solve this by designating another regular UNIX node as a \"locking node\": nodes['my.k8s.cluster'] = { 'locking_node': 'my.openbsd.box', 'os': 'kubernetes', 'metadata': { ... }, } my.openbsd.box is the name of another regular node, which must be managed by BundleWrap. You can now use all the usual locking mechanisms when working with my.k8s.cluster and its locks will be stored on my.openbsd.box . (They will, of course, not conflict with regular locks for my.openbsd.box .) A locking node can host locks for as many other nodes as you wish.","title":"Locking non-UNIX nodes"},{"location":"guide/migrate_12/","text":"Migrating from BundleWrap 1.x to 2.x As per semver , BundleWrap 2.0 breaks compatibility with repositories created for BundleWrap 1.x. This document provides a guide on how to upgrade your repositories to BundleWrap 2.x. Please read the entire document before proceeding. To aid with the transition, BundleWrap 1.6.0 has been released along with 2.0.0. It contains no new features over 1.5.x, but has builtin helpers to aid your migration to 2.0. items.py In every bundle, rename bundle.py to items.py . BundleWrap 1.6.0 can do this for you by running bw migrate . Default file content type The default content_type for file items has changed from \"mako\" to \"text\". This means that you need to check all file items that do not define an explicit content type of \"mako\". Some of them might be fine because you didn't really need templating, while others may need to have their content_type set to \"mako\" explicitly. BundleWrap 1.6.0 will print warnings for every file item affected when running bw test . Metadata merging The merging behavior for node and group metadata has changed. Instead of a simple dict.update() , metadata dicts are now merged recursively. See the docs for details. Metadata processors and item generators These two advanced features have been replaced by a single new mechanism: metadata.py You will need to rethink and rewrite them. BundleWrap 1.6.0 will print warnings for every group that uses metadata processors and any item generators when running bw test . Custom item types The API for defining your own items has changed. Generally, you should be able to upgrade your items with relatively little effort. Refer to the docs for details. Deterministic templates While not a strict requirement, it is highly recommended to ensure your entire configuration can be created deterministically (i.e. remains exactly the same no matter how often you generate it). Otherwise, you won't be able to take advantage of the new functionality provided by bw hash . A common pitfall here is iteration over dictionaries in templates: % for key, value in my_dict.items(): ${value} % endfor Standard dictionaries in Python have no defined order. This may result in lines occasionally changing their position. To solve this, you can simply use sorted() : % for key, value in sorted(my_dict.items()): ${value} % endfor Hook arguments Some hooks had their arguments adjusted slightly.","title":"Migrating to 2.0"},{"location":"guide/migrate_12/#migrating-from-bundlewrap-1x-to-2x","text":"As per semver , BundleWrap 2.0 breaks compatibility with repositories created for BundleWrap 1.x. This document provides a guide on how to upgrade your repositories to BundleWrap 2.x. Please read the entire document before proceeding. To aid with the transition, BundleWrap 1.6.0 has been released along with 2.0.0. It contains no new features over 1.5.x, but has builtin helpers to aid your migration to 2.0.","title":"Migrating from BundleWrap 1.x to 2.x"},{"location":"guide/migrate_12/#itemspy","text":"In every bundle, rename bundle.py to items.py . BundleWrap 1.6.0 can do this for you by running bw migrate .","title":"items.py"},{"location":"guide/migrate_12/#default-file-content-type","text":"The default content_type for file items has changed from \"mako\" to \"text\". This means that you need to check all file items that do not define an explicit content type of \"mako\". Some of them might be fine because you didn't really need templating, while others may need to have their content_type set to \"mako\" explicitly. BundleWrap 1.6.0 will print warnings for every file item affected when running bw test .","title":"Default file content type"},{"location":"guide/migrate_12/#metadata-merging","text":"The merging behavior for node and group metadata has changed. Instead of a simple dict.update() , metadata dicts are now merged recursively. See the docs for details.","title":"Metadata merging"},{"location":"guide/migrate_12/#metadata-processors-and-item-generators","text":"These two advanced features have been replaced by a single new mechanism: metadata.py You will need to rethink and rewrite them. BundleWrap 1.6.0 will print warnings for every group that uses metadata processors and any item generators when running bw test .","title":"Metadata processors and item generators"},{"location":"guide/migrate_12/#custom-item-types","text":"The API for defining your own items has changed. Generally, you should be able to upgrade your items with relatively little effort. Refer to the docs for details.","title":"Custom item types"},{"location":"guide/migrate_12/#deterministic-templates","text":"While not a strict requirement, it is highly recommended to ensure your entire configuration can be created deterministically (i.e. remains exactly the same no matter how often you generate it). Otherwise, you won't be able to take advantage of the new functionality provided by bw hash . A common pitfall here is iteration over dictionaries in templates: % for key, value in my_dict.items(): ${value} % endfor Standard dictionaries in Python have no defined order. This may result in lines occasionally changing their position. To solve this, you can simply use sorted() : % for key, value in sorted(my_dict.items()): ${value} % endfor","title":"Deterministic templates"},{"location":"guide/migrate_12/#hook-arguments","text":"Some hooks had their arguments adjusted slightly.","title":"Hook arguments"},{"location":"guide/migrate_23/","text":"Migrating from BundleWrap 2.x to 3.x As per semver , BundleWrap 3.0 breaks compatibility with repositories created for BundleWrap 2.x. This document provides a guide on how to upgrade your repositories to BundleWrap 3.x. Please read the entire document before proceeding. metadata.py BundleWrap 2.x simply used all functions in metadata.py whose names don't start with an underscore as metadata processors. This led to awkward imports like from foo import bar as _bar . BundleWrap 3.x requires a decorator for explicitly designating functions as metadata processors: @metadata_processor def myproc(metadata): return metadata, DONE You will have to add @metadata_processor to each metadata processor function. There is no need to import it; it is provided automatically, just like node and repo . The accepted return values of metadata processors have changed as well. Metadata processors now always have to return a tuple with the first element being a dictionary of metadata and the remaining elements made up of various options to tell BundleWrap what to do with the dictionary. In most cases, you will want to return the DONE options as in the example above. There is no need to import options, they're always available. When you previously returned metadata, False from a metadata processor, you will now have to return metadata, RUN_ME_AGAIN . For a more detailed description of the available options, see the documentation . File and directory ownership defaults Files , directories , and symlinks now have default values for the ownership and mode attributes. Previously the default was to ignore them. It's very likely that you won't have to do anything here, just be aware. systemd services enabled by default Again, just be aware , it's probably what you intended anyway. Environment variables The following env vars have been renamed (though the new names have already been available for a while, so chances are you're already using them): Old New BWADDHOSTKEYS BW_ADD_HOST_KEYS BWCOLORS BW_COLORS BWITEMWORKERS BW_ITEM_WORKERS BWNODEWORKERS BW_NODE_WORKERS Item.display_keys and Item.display_dicts If you've written your own items and used the display_keys() or display_dicts() methods or the BLOCK_CONCURRENT attribute, you will have to update them to the new API .","title":"Migrating to 3.0"},{"location":"guide/migrate_23/#migrating-from-bundlewrap-2x-to-3x","text":"As per semver , BundleWrap 3.0 breaks compatibility with repositories created for BundleWrap 2.x. This document provides a guide on how to upgrade your repositories to BundleWrap 3.x. Please read the entire document before proceeding.","title":"Migrating from BundleWrap 2.x to 3.x"},{"location":"guide/migrate_23/#metadatapy","text":"BundleWrap 2.x simply used all functions in metadata.py whose names don't start with an underscore as metadata processors. This led to awkward imports like from foo import bar as _bar . BundleWrap 3.x requires a decorator for explicitly designating functions as metadata processors: @metadata_processor def myproc(metadata): return metadata, DONE You will have to add @metadata_processor to each metadata processor function. There is no need to import it; it is provided automatically, just like node and repo . The accepted return values of metadata processors have changed as well. Metadata processors now always have to return a tuple with the first element being a dictionary of metadata and the remaining elements made up of various options to tell BundleWrap what to do with the dictionary. In most cases, you will want to return the DONE options as in the example above. There is no need to import options, they're always available. When you previously returned metadata, False from a metadata processor, you will now have to return metadata, RUN_ME_AGAIN . For a more detailed description of the available options, see the documentation .","title":"metadata.py"},{"location":"guide/migrate_23/#file-and-directory-ownership-defaults","text":"Files , directories , and symlinks now have default values for the ownership and mode attributes. Previously the default was to ignore them. It's very likely that you won't have to do anything here, just be aware.","title":"File and directory ownership defaults"},{"location":"guide/migrate_23/#systemd-services-enabled-by-default","text":"Again, just be aware , it's probably what you intended anyway.","title":"systemd services enabled by default"},{"location":"guide/migrate_23/#environment-variables","text":"The following env vars have been renamed (though the new names have already been available for a while, so chances are you're already using them): Old New BWADDHOSTKEYS BW_ADD_HOST_KEYS BWCOLORS BW_COLORS BWITEMWORKERS BW_ITEM_WORKERS BWNODEWORKERS BW_NODE_WORKERS","title":"Environment variables"},{"location":"guide/migrate_23/#itemdisplay_keys-and-itemdisplay_dicts","text":"If you've written your own items and used the display_keys() or display_dicts() methods or the BLOCK_CONCURRENT attribute, you will have to update them to the new API .","title":"Item.display_keys and Item.display_dicts"},{"location":"guide/migrate_34/","text":"Migrating from BundleWrap 3.x to 4.x As per semver , BundleWrap 4.0 breaks compatibility with repositories created for BundleWrap 3.x. This document provides a guide on how to upgrade your repositories to BundleWrap 4.x. Please read the entire document before proceeding. metadata.py Metadata processors have been split into defaults and reactors. See metadata.py for details. Generally speaking, metadata processors that returned DONE, DEFAULTS can be turned into defaults. @metadata_processor def foo(metadata): return {\"bar\": 47} becomes defaults = { \"bar\": 47, } Metadata processors that return OVERWRITE, RUN_ME_AGAIN or otherwise depend on other metadata need to be turned into reactors: @metadata_processor def foo(metadata): metadata[\"bar\"] = metadata[\"baz\"] + 5 return metadata, OVERWRITE, RUN_ME_AGAIN becomes @metadata_reactor def foo(metadata): return { \"bar\": metadata.get(\"baz\") + 5, } members_add and members_remove These must be replaced by other mechanism, such as the newly-available groups attribute on individual nodes. Also note that you can now do bw apply 'lambda:node.metadata[\"env\"] == \"prod\"' so you may no longer have a need to create groups based on metadata. Plugins The plugin system has been removed since it saw barely any use. The most popular plugin, the git_deploy item is now built into BundleWrap itself. rm plugins.json rm items/git_deploy.py Command line argument parsing Previously, bw used a comma-separated syntax to specify targets for certain actions such as bw apply . We now use a space separated style: bw apply node1,node2 becomes bw apply node1 node2 This may appear trivial, but might lead to confusion with people not used to providing multiple multi-value space-separated arguments on the command line. bw nodes -a all node1 becomes bw nodes -a all -- node1 The -- is necessary so we can tell when the argument list for -a ends. Here is another example: bw nodes -a hostname,bundles node1,node2 becomes bw nodes -a hostname bundles -- node1 node2 While a little more verbose, this style let's us use proper shell quoting for argument tokens. Minor changes For everything else, please consult the changelog .","title":"Migrating to 4.0"},{"location":"guide/migrate_34/#migrating-from-bundlewrap-3x-to-4x","text":"As per semver , BundleWrap 4.0 breaks compatibility with repositories created for BundleWrap 3.x. This document provides a guide on how to upgrade your repositories to BundleWrap 4.x. Please read the entire document before proceeding.","title":"Migrating from BundleWrap 3.x to 4.x"},{"location":"guide/migrate_34/#metadatapy","text":"Metadata processors have been split into defaults and reactors. See metadata.py for details. Generally speaking, metadata processors that returned DONE, DEFAULTS can be turned into defaults. @metadata_processor def foo(metadata): return {\"bar\": 47} becomes defaults = { \"bar\": 47, } Metadata processors that return OVERWRITE, RUN_ME_AGAIN or otherwise depend on other metadata need to be turned into reactors: @metadata_processor def foo(metadata): metadata[\"bar\"] = metadata[\"baz\"] + 5 return metadata, OVERWRITE, RUN_ME_AGAIN becomes @metadata_reactor def foo(metadata): return { \"bar\": metadata.get(\"baz\") + 5, }","title":"metadata.py"},{"location":"guide/migrate_34/#members_add-and-members_remove","text":"These must be replaced by other mechanism, such as the newly-available groups attribute on individual nodes. Also note that you can now do bw apply 'lambda:node.metadata[\"env\"] == \"prod\"' so you may no longer have a need to create groups based on metadata.","title":"members_add and members_remove"},{"location":"guide/migrate_34/#plugins","text":"The plugin system has been removed since it saw barely any use. The most popular plugin, the git_deploy item is now built into BundleWrap itself. rm plugins.json rm items/git_deploy.py","title":"Plugins"},{"location":"guide/migrate_34/#command-line-argument-parsing","text":"Previously, bw used a comma-separated syntax to specify targets for certain actions such as bw apply . We now use a space separated style: bw apply node1,node2 becomes bw apply node1 node2 This may appear trivial, but might lead to confusion with people not used to providing multiple multi-value space-separated arguments on the command line. bw nodes -a all node1 becomes bw nodes -a all -- node1 The -- is necessary so we can tell when the argument list for -a ends. Here is another example: bw nodes -a hostname,bundles node1,node2 becomes bw nodes -a hostname bundles -- node1 node2 While a little more verbose, this style let's us use proper shell quoting for argument tokens.","title":"Command line argument parsing"},{"location":"guide/migrate_34/#minor-changes","text":"For everything else, please consult the changelog .","title":"Minor changes"},{"location":"guide/os_compatibility/","text":"OS compatibility BundleWrap by necessity takes a pragmatic approach to supporting different operating systems and distributions. Our main target is Linux, but support for other UNIXes is also evolving. We cannot guarantee to be compatible with every distribution and BSD flavor under the sun, but we try to cover the common ones. node.os and node.os_version You should set these attributes for every node. Giving BundleWrap this information allows us to adapt some built-in behavior. other node attributes In some cases (e.g. when not using sudo) you will need to manually adjust some things. Check the docs on node-level OS overrides .","title":"OS compatibility"},{"location":"guide/os_compatibility/#os-compatibility","text":"BundleWrap by necessity takes a pragmatic approach to supporting different operating systems and distributions. Our main target is Linux, but support for other UNIXes is also evolving. We cannot guarantee to be compatible with every distribution and BSD flavor under the sun, but we try to cover the common ones.","title":"OS compatibility"},{"location":"guide/os_compatibility/#nodeos-and-nodeos_version","text":"You should set these attributes for every node. Giving BundleWrap this information allows us to adapt some built-in behavior.","title":"node.os and node.os_version"},{"location":"guide/os_compatibility/#other-node-attributes","text":"In some cases (e.g. when not using sudo) you will need to manually adjust some things. Check the docs on node-level OS overrides .","title":"other node attributes"},{"location":"guide/quickstart/","text":"Quickstart This is the 10 minute intro into BundleWrap. Fasten your seatbelt. Installation First, open a terminal and install BundleWrap: pip install bundlewrap Create a repository Now you'll need to create your repository : mkdir my_bundlewrap_repo cd my_bundlewrap_repo bw repo create You will note that some files have been created. Let's check them out: cat nodes.py cat groups.py The contents should be fairly self-explanatory, but you can always check the docs on these files if you want to go deeper. It is highly recommended to use git or a similar tool to keep track of your repository. You may want to start doing that right away. At this point you will want to edit nodes.py and maybe change \"localhost\" to the hostname of a system you have passwordless (including sudo) SSH access to. BundleWrap will honor your ~/.ssh/config , so if ssh mynode.example.com sudo id works without any password prompts in your terminal, you're good to go. If you want to keep working on \"localhost\", then the above still applies in that ssh localhost sudo id needs to work without any password prompts. Verify that: an SSH daemon is listening on 127.0.0.1 a relevant public key is in the ~/.ssh/authorized_keys file the ~/.ssh/authorized_keys file is not world-writable your user or group has ALL=(ALL) NOPASSWD: ALL set in the /etc/sudoers file Run a command The first thing you can do is run a command on your army of one node: bw -a run node-1 \"uptime\" The -a switch tells bw to automatically trust unknown SSH host keys (when you're connecting to a new node). By default, only known host keys will be accepted. You should see something like this: \u203a node-1 20:16:26 up 34 days, 4:10, 0 users, load average: 0.00, 0.01, 0.05 \u2713 node-1 completed after 0.366s Instead of a node name (\"node-1\" in this case) you can also use a group name (such as \"all\") from your groups.py . Create a bundle BundleWrap stores node configuration in bundles. A bundle is a collection of items such as files, system packages or users. To create your first bundle, type: bw repo bundle create mybundle Now that you have created your bundle, it's important to tell BundleWrap which nodes will have this bundle. You can assign bundles to nodes using either groups.py or nodes.py , here we'll use the latter: nodes = { 'node-1': { 'bundles': ( \"mybundle\", ), 'hostname': \"mynode-1.local\", }, } Create a file template To manage a file, you need two things: a file item in your bundle a template for the file contents Add this to your bundles/mybundle/items.py : files = { '/etc/motd': { 'content_type': 'mako', # use the Mako template engine for this file 'source': \"mymotd\", # filename of the template }, } Then write the file template: vim bundles/mybundle/files/mymotd You can use this for example content: Welcome to ${node.name}! Note that the source attribute in items.py contains a path relative to the files directory of your bundle. Apply configuration Now all that's left is to run bw apply : bw apply -i node-1 BundleWrap will ask to replace your previous MOTD: i node-1 started at 2016-02-13 21:25:45 ? node-1 ? node-1 \u256d\u2500 file:/etc/motd ? node-1 \u2502 ? node-1 \u2502 content ? node-1 \u2502 --- <node> ? node-1 \u2502 +++ <bundlewrap> ? node-1 \u2502 @@ -1 +1 @@ ? node-1 \u2502 -your old motd ? node-1 \u2502 +Welcome to node-1! ? node-1 \u2502 ? node-1 \u2570\u2500 Fix file:/etc/motd? [Y/n] That completes the quickstart tutorial! Further reading Here are some suggestions on what to do next: set up SSH multiplexing for significantly better performance take a moment to think about what groups and bundles you will create read up on how a BundleWrap repository is laid out ...especially what types of items you can add to your bundles familiarize yourself with the Mako template language explore the command line interface follow @bundlewrap on Twitter Have fun! If you have any questions, feel free to drop by on IRC or GitHub .","title":"Quickstart"},{"location":"guide/quickstart/#quickstart","text":"This is the 10 minute intro into BundleWrap. Fasten your seatbelt.","title":"Quickstart"},{"location":"guide/quickstart/#installation","text":"First, open a terminal and install BundleWrap: pip install bundlewrap","title":"Installation"},{"location":"guide/quickstart/#create-a-repository","text":"Now you'll need to create your repository : mkdir my_bundlewrap_repo cd my_bundlewrap_repo bw repo create You will note that some files have been created. Let's check them out: cat nodes.py cat groups.py The contents should be fairly self-explanatory, but you can always check the docs on these files if you want to go deeper. It is highly recommended to use git or a similar tool to keep track of your repository. You may want to start doing that right away. At this point you will want to edit nodes.py and maybe change \"localhost\" to the hostname of a system you have passwordless (including sudo) SSH access to. BundleWrap will honor your ~/.ssh/config , so if ssh mynode.example.com sudo id works without any password prompts in your terminal, you're good to go. If you want to keep working on \"localhost\", then the above still applies in that ssh localhost sudo id needs to work without any password prompts. Verify that: an SSH daemon is listening on 127.0.0.1 a relevant public key is in the ~/.ssh/authorized_keys file the ~/.ssh/authorized_keys file is not world-writable your user or group has ALL=(ALL) NOPASSWD: ALL set in the /etc/sudoers file","title":"Create a repository"},{"location":"guide/quickstart/#run-a-command","text":"The first thing you can do is run a command on your army of one node: bw -a run node-1 \"uptime\" The -a switch tells bw to automatically trust unknown SSH host keys (when you're connecting to a new node). By default, only known host keys will be accepted. You should see something like this: \u203a node-1 20:16:26 up 34 days, 4:10, 0 users, load average: 0.00, 0.01, 0.05 \u2713 node-1 completed after 0.366s Instead of a node name (\"node-1\" in this case) you can also use a group name (such as \"all\") from your groups.py .","title":"Run a command"},{"location":"guide/quickstart/#create-a-bundle","text":"BundleWrap stores node configuration in bundles. A bundle is a collection of items such as files, system packages or users. To create your first bundle, type: bw repo bundle create mybundle Now that you have created your bundle, it's important to tell BundleWrap which nodes will have this bundle. You can assign bundles to nodes using either groups.py or nodes.py , here we'll use the latter: nodes = { 'node-1': { 'bundles': ( \"mybundle\", ), 'hostname': \"mynode-1.local\", }, }","title":"Create a bundle"},{"location":"guide/quickstart/#create-a-file-template","text":"To manage a file, you need two things: a file item in your bundle a template for the file contents Add this to your bundles/mybundle/items.py : files = { '/etc/motd': { 'content_type': 'mako', # use the Mako template engine for this file 'source': \"mymotd\", # filename of the template }, } Then write the file template: vim bundles/mybundle/files/mymotd You can use this for example content: Welcome to ${node.name}! Note that the source attribute in items.py contains a path relative to the files directory of your bundle.","title":"Create a file template"},{"location":"guide/quickstart/#apply-configuration","text":"Now all that's left is to run bw apply : bw apply -i node-1 BundleWrap will ask to replace your previous MOTD: i node-1 started at 2016-02-13 21:25:45 ? node-1 ? node-1 \u256d\u2500 file:/etc/motd ? node-1 \u2502 ? node-1 \u2502 content ? node-1 \u2502 --- <node> ? node-1 \u2502 +++ <bundlewrap> ? node-1 \u2502 @@ -1 +1 @@ ? node-1 \u2502 -your old motd ? node-1 \u2502 +Welcome to node-1! ? node-1 \u2502 ? node-1 \u2570\u2500 Fix file:/etc/motd? [Y/n] That completes the quickstart tutorial!","title":"Apply configuration"},{"location":"guide/quickstart/#further-reading","text":"Here are some suggestions on what to do next: set up SSH multiplexing for significantly better performance take a moment to think about what groups and bundles you will create read up on how a BundleWrap repository is laid out ...especially what types of items you can add to your bundles familiarize yourself with the Mako template language explore the command line interface follow @bundlewrap on Twitter Have fun! If you have any questions, feel free to drop by on IRC or GitHub .","title":"Further reading"},{"location":"guide/secrets/","text":"Handling secrets We strongly recommend not putting any sensitive information such as passwords or private keys into your repository. This page describes the helpers available in BundleWrap to manage those secrets without checking them into version control. Most of the functions described here return lazy Fault objects . .secrets.cfg When you initially ran bw repo create , a file called .secrets.cfg was put into the root level of your repo. It's an INI-style file that by default contains two random keys BundleWrap uses to protect your secrets. One for randomly generated passwords, one for symmetric encryption. You should never commit .secrets.cfg . Immediately add it to your .gitignore or equivalent. Derived passwords In some cases, you can control (i.e. manage with BundleWrap) both ends of the authentication process. A common example is a config file for a web application that holds credentials for a database also managed by BundleWrap. In this case, you don't really care what the password is, you just want it to be the same on both sides. To accomplish that, just write this in your template (Mako syntax shown here): database_user = \"foo\" database_password = \"${repo.vault.password_for(\"my database\")}\" In your bundle, you can then configure your database user like this: postgres_roles = { \"foo\": { 'password': repo.vault.password_for(\"my database\"), }, } It doesn't really matter what string you call password_for() with, it just has to be the same on both ends. BundleWrap will then use that string, combine it with the default key called generate in your .secrets.cfg and derive a random password from that. This makes it easy to change all your passwords at once (e.g. when an employee leaves or when required for compliance reasons) by rotating keys. However, it also means you have to guard your .secrets.cfg very closely. If it is compromised, so are all your passwords. Use your own judgement. \"Human\" passwords As an alternative to password_for() , which generates random strings, you can use human_password_for() .It generates strings like Wiac-Kaobl-Teuh-Kumd-40 . They are easier to handle for human beings. You might want to use them if you have to type those passwords on a regular basis. Random bytes password_for() and human_password_for() are meant for passwords. If you need plain random bytes, you can use random_bytes_as_base64_for() . As the name implies, it will return the data base64 encoded. Some examples: $ bw debug -c 'print(repo.vault.random_bytes_as_base64_for(\"foo\"))' qczM0GUKW7YlXEuW8HGPYkjCGaX4Vu9Fja5SIZWga7w= $ bw debug -c 'print(repo.vault.random_bytes_as_base64_for(\"foo\", length=1))' qQ== Static passwords When you need to store a specific password, you can encrypt it symmetrically. The bw pw utility provides command line access to the functions attached to repo.vault , so we'll use it here to generate the encrypted string: $ bw pw --encrypt 'my password' gAAAA[...]mrVMA== You can then use this encrypted password in a template like this: database_user = \"foo\" database_password = \"${repo.vault.decrypt(\"gAAAA[...]mrVMA==\")}\" Files You can also encrypt entire files: $ bw pw --encrypt --file encrypted.file /my/secret.file Encrypted files are always read and written relative to the data/ subdirectory of your repo. If the source file was encoded using UTF-8, you can then simply pass the decrypted content into a file item: files = { \"/secret\": { 'content': repo.vault.decrypt_file(\"encrypted.file\"), }, } If the source file is binary however (or any encoding other than UTF-8), you must use base64: files = { \"/secret\": { 'content': repo.vault.decrypt_file_as_base64(\"encrypted.file\"), 'content_type': 'base64', }, } External commands To retrieve secrets using a local shell command, use vault.cmd : $ bw debug -c \"print(repo.vault.cmd('uname'))\" Linux By default, the stdout of the given command will be decoded to text using UTF-8 and have leading and trailing whitespace stripped. To prevent this, use the as_text and strip parameters: $ bw debug -c \"print(repo.vault.cmd('uname', as_text=False, strip=False))\" b'Linux\\n' The point of using repo.vault.cmd() is that (like the other functions introduced on this page) it will return a lazy Fault object that will call the command only if and when the value is actually needed (e.g. when rendering a file template). Key management Multiple keys You can always add more keys to your .secrets.cfg , but you should keep the defaults around. Adding more keys makes it possible to give different keys to different teams. By default, BundleWrap will skip items it can't find the required keys for . When using .password_for() , .encrypt() etc., you can provide a key argument to select the key: repo.vault.password_for(\"some database\", key=\"devops\") On the command line, bw pw also accepts --key for this purpose. The encrypted data will be prefixed by yourkeyname$... to indicate that the key yourkeyname was used for encryption. Thus, during decryption, you can omit the key= parameter. Rotating keys You can generate a new key by running bw debug -c \"print(repo.vault.random_key())\" . Place the result in your .secrets.cfg . Then you need to distribute the new key to your team and run bw apply for all your nodes. Note that `encrypt()` and `decrypt()` (plus their `file_` counterparts) use symmetric encryption and require manually updating the encrypted text after the key has changed. Reading keys from external sources If you'd rather not have plaintext keys in your .secrets.cfg , you can use key_command instead of key to specify a shell command that will be invoked to retrieve the key. Whitespace around the output will be stripped automatically. [encrypt] key_command = curl localhost:12345/secret If both key and key_command are present, key_command will be ignored.","title":"Handling secrets"},{"location":"guide/secrets/#handling-secrets","text":"We strongly recommend not putting any sensitive information such as passwords or private keys into your repository. This page describes the helpers available in BundleWrap to manage those secrets without checking them into version control. Most of the functions described here return lazy Fault objects .","title":"Handling secrets"},{"location":"guide/secrets/#secretscfg","text":"When you initially ran bw repo create , a file called .secrets.cfg was put into the root level of your repo. It's an INI-style file that by default contains two random keys BundleWrap uses to protect your secrets. One for randomly generated passwords, one for symmetric encryption. You should never commit .secrets.cfg . Immediately add it to your .gitignore or equivalent.","title":".secrets.cfg"},{"location":"guide/secrets/#derived-passwords","text":"In some cases, you can control (i.e. manage with BundleWrap) both ends of the authentication process. A common example is a config file for a web application that holds credentials for a database also managed by BundleWrap. In this case, you don't really care what the password is, you just want it to be the same on both sides. To accomplish that, just write this in your template (Mako syntax shown here): database_user = \"foo\" database_password = \"${repo.vault.password_for(\"my database\")}\" In your bundle, you can then configure your database user like this: postgres_roles = { \"foo\": { 'password': repo.vault.password_for(\"my database\"), }, } It doesn't really matter what string you call password_for() with, it just has to be the same on both ends. BundleWrap will then use that string, combine it with the default key called generate in your .secrets.cfg and derive a random password from that. This makes it easy to change all your passwords at once (e.g. when an employee leaves or when required for compliance reasons) by rotating keys. However, it also means you have to guard your .secrets.cfg very closely. If it is compromised, so are all your passwords. Use your own judgement.","title":"Derived passwords"},{"location":"guide/secrets/#human-passwords","text":"As an alternative to password_for() , which generates random strings, you can use human_password_for() .It generates strings like Wiac-Kaobl-Teuh-Kumd-40 . They are easier to handle for human beings. You might want to use them if you have to type those passwords on a regular basis.","title":"\"Human\" passwords"},{"location":"guide/secrets/#random-bytes","text":"password_for() and human_password_for() are meant for passwords. If you need plain random bytes, you can use random_bytes_as_base64_for() . As the name implies, it will return the data base64 encoded. Some examples: $ bw debug -c 'print(repo.vault.random_bytes_as_base64_for(\"foo\"))' qczM0GUKW7YlXEuW8HGPYkjCGaX4Vu9Fja5SIZWga7w= $ bw debug -c 'print(repo.vault.random_bytes_as_base64_for(\"foo\", length=1))' qQ==","title":"Random bytes"},{"location":"guide/secrets/#static-passwords","text":"When you need to store a specific password, you can encrypt it symmetrically. The bw pw utility provides command line access to the functions attached to repo.vault , so we'll use it here to generate the encrypted string: $ bw pw --encrypt 'my password' gAAAA[...]mrVMA== You can then use this encrypted password in a template like this: database_user = \"foo\" database_password = \"${repo.vault.decrypt(\"gAAAA[...]mrVMA==\")}\"","title":"Static passwords"},{"location":"guide/secrets/#files","text":"You can also encrypt entire files: $ bw pw --encrypt --file encrypted.file /my/secret.file Encrypted files are always read and written relative to the data/ subdirectory of your repo. If the source file was encoded using UTF-8, you can then simply pass the decrypted content into a file item: files = { \"/secret\": { 'content': repo.vault.decrypt_file(\"encrypted.file\"), }, } If the source file is binary however (or any encoding other than UTF-8), you must use base64: files = { \"/secret\": { 'content': repo.vault.decrypt_file_as_base64(\"encrypted.file\"), 'content_type': 'base64', }, }","title":"Files"},{"location":"guide/secrets/#external-commands","text":"To retrieve secrets using a local shell command, use vault.cmd : $ bw debug -c \"print(repo.vault.cmd('uname'))\" Linux By default, the stdout of the given command will be decoded to text using UTF-8 and have leading and trailing whitespace stripped. To prevent this, use the as_text and strip parameters: $ bw debug -c \"print(repo.vault.cmd('uname', as_text=False, strip=False))\" b'Linux\\n' The point of using repo.vault.cmd() is that (like the other functions introduced on this page) it will return a lazy Fault object that will call the command only if and when the value is actually needed (e.g. when rendering a file template).","title":"External commands"},{"location":"guide/secrets/#key-management","text":"","title":"Key management"},{"location":"guide/secrets/#multiple-keys","text":"You can always add more keys to your .secrets.cfg , but you should keep the defaults around. Adding more keys makes it possible to give different keys to different teams. By default, BundleWrap will skip items it can't find the required keys for . When using .password_for() , .encrypt() etc., you can provide a key argument to select the key: repo.vault.password_for(\"some database\", key=\"devops\") On the command line, bw pw also accepts --key for this purpose. The encrypted data will be prefixed by yourkeyname$... to indicate that the key yourkeyname was used for encryption. Thus, during decryption, you can omit the key= parameter.","title":"Multiple keys"},{"location":"guide/secrets/#rotating-keys","text":"You can generate a new key by running bw debug -c \"print(repo.vault.random_key())\" . Place the result in your .secrets.cfg . Then you need to distribute the new key to your team and run bw apply for all your nodes. Note that `encrypt()` and `decrypt()` (plus their `file_` counterparts) use symmetric encryption and require manually updating the encrypted text after the key has changed.","title":"Rotating keys"},{"location":"guide/secrets/#reading-keys-from-external-sources","text":"If you'd rather not have plaintext keys in your .secrets.cfg , you can use key_command instead of key to specify a shell command that will be invoked to retrieve the key. Whitespace around the output will be stripped automatically. [encrypt] key_command = curl localhost:12345/secret If both key and key_command are present, key_command will be ignored.","title":"Reading keys from external sources"},{"location":"guide/selectors/","text":"Node selectors These can be used on the command line to select a number of nodes. See bw apply --help for a list of possible uses. Item selectors Item selectors provide a way to address multiple items e.g. when specifying dependencies between them. Example selector Meaning file:/etc/motd a single item file: all items of that type bundle:foo all items in that bundle tag:foo all items with that tag tag: all items with any tag All selectors can be prefixed with ! to select the inverse (e.g. !tag: means \"all items without any tag\"). Note that when you have a file item and add a dependency to file: , BundleWrap will resolve this to all other files. Similarily, when you add a dependency on tag: to all items with a certain tag through bundle.py , this will only target other tags to avoid an immediate loop.","title":"Selectors"},{"location":"guide/selectors/#node-selectors","text":"These can be used on the command line to select a number of nodes. See bw apply --help for a list of possible uses.","title":"Node selectors"},{"location":"guide/selectors/#item-selectors","text":"Item selectors provide a way to address multiple items e.g. when specifying dependencies between them. Example selector Meaning file:/etc/motd a single item file: all items of that type bundle:foo all items in that bundle tag:foo all items with that tag tag: all items with any tag All selectors can be prefixed with ! to select the inverse (e.g. !tag: means \"all items without any tag\"). Note that when you have a file item and add a dependency to file: , BundleWrap will resolve this to all other files. Similarily, when you add a dependency on tag: to all items with a certain tag through bundle.py , this will only target other tags to avoid an immediate loop.","title":"Item selectors"},{"location":"guide/toml/","text":"TOML nodes and groups The primary way to define nodes is in nodes.py . However, BundleWrap also provides a built-in alternative that you can use to define each node in a TOML file. Doing this has pros and cons, which is why you can choose which way is best for you. Pros One file per node Node files are machine-readable and -writeable Easier on the eyes for nodes with simple metadata Cons Does not support Fault objects Does not support atomic() Does not support None Does not support sets or tuples More difficult to read for long, deeply nested metadata Using TOML nodes First, you have to make sure your nodes.py doesn't overwrite your TOML nodes. Check if your nodes.py overwrites the nodes dict: nodes = { # bad \"my_node\": {...}, } TOML nodes will be added to the nodes.py context automatically, so change your nodes.py to add to them (or just leave the file empty): nodes[\"my_node\"] = { # good ... } Now you are all set to create your first TOML node. Create a file called nodes/nodenamegoeshere.toml : hostname = \"tomlnode.example.com\" bundles = [ \"bundle1\", \"bundle2\", ] [metadata] foo = \"bar\" [metadata.baz] frob = 47 And that's it. This node will now be added to your other nodes. You may use subdirectories of nodes/ , but the node name will always just be the filename minus the \".toml\" extension. Converting existing nodes This is an easy one line operation: bw debug -n nodenamegoeshere -c \"node.toml_save()\" Don't forget to remove the original node though. Editing TOML nodes from Python BundleWrap uses tomlkit internally and exposes a TOMLDocument instance as node.toml for you to modify: $ bw debug -n nodenamegoeshere >>> node.file_path nodes/nodenamegoeshere.toml >>> node.toml['bundles'].append(\"bundle3\") >>> node.toml_save() For your convenience, .toml_set() is also provided to easily set nested dict values: >>> node.toml_set(\"metadata/foo/bar/baz\", 47) >>> node.toml_save() This should make it pretty straightforward to make changes to lots of nodes without the headaches of using sed or something of that nature to edit Python code in nodes.py . TOML groups They work exactly the same way as nodes, but have their own groups/ directory. .toml , .toml_set() and toml_save() are also found on Group objects.","title":"TOML nodes and groups"},{"location":"guide/toml/#toml-nodes-and-groups","text":"The primary way to define nodes is in nodes.py . However, BundleWrap also provides a built-in alternative that you can use to define each node in a TOML file. Doing this has pros and cons, which is why you can choose which way is best for you. Pros One file per node Node files are machine-readable and -writeable Easier on the eyes for nodes with simple metadata Cons Does not support Fault objects Does not support atomic() Does not support None Does not support sets or tuples More difficult to read for long, deeply nested metadata","title":"TOML nodes and groups"},{"location":"guide/toml/#using-toml-nodes","text":"First, you have to make sure your nodes.py doesn't overwrite your TOML nodes. Check if your nodes.py overwrites the nodes dict: nodes = { # bad \"my_node\": {...}, } TOML nodes will be added to the nodes.py context automatically, so change your nodes.py to add to them (or just leave the file empty): nodes[\"my_node\"] = { # good ... } Now you are all set to create your first TOML node. Create a file called nodes/nodenamegoeshere.toml : hostname = \"tomlnode.example.com\" bundles = [ \"bundle1\", \"bundle2\", ] [metadata] foo = \"bar\" [metadata.baz] frob = 47 And that's it. This node will now be added to your other nodes. You may use subdirectories of nodes/ , but the node name will always just be the filename minus the \".toml\" extension.","title":"Using TOML nodes"},{"location":"guide/toml/#converting-existing-nodes","text":"This is an easy one line operation: bw debug -n nodenamegoeshere -c \"node.toml_save()\" Don't forget to remove the original node though.","title":"Converting existing nodes"},{"location":"guide/toml/#editing-toml-nodes-from-python","text":"BundleWrap uses tomlkit internally and exposes a TOMLDocument instance as node.toml for you to modify: $ bw debug -n nodenamegoeshere >>> node.file_path nodes/nodenamegoeshere.toml >>> node.toml['bundles'].append(\"bundle3\") >>> node.toml_save() For your convenience, .toml_set() is also provided to easily set nested dict values: >>> node.toml_set(\"metadata/foo/bar/baz\", 47) >>> node.toml_save() This should make it pretty straightforward to make changes to lots of nodes without the headaches of using sed or something of that nature to edit Python code in nodes.py .","title":"Editing TOML nodes from Python"},{"location":"guide/toml/#toml-groups","text":"They work exactly the same way as nodes, but have their own groups/ directory. .toml , .toml_set() and toml_save() are also found on Group objects.","title":"TOML groups"},{"location":"items/action/","text":"Actions Actions will be run on every bw apply . They differ from regular items in that they cannot be \"correct\" in the first place. They can only succeed or fail. actions = { 'check_if_its_still_linux': { 'command': \"uname\", 'expected_return_code': 0, 'expected_stdout': \"Linux\\n\", }, } Attribute reference See also: The list of generic builtin item attributes command The only required attribute. This is the command that will be run on the node with root privileges. data_stdin You can pipe data directly to the command running on the node. To do so, use this attribute. If it's a string or unicode object, it will always be encoded as UTF-8. Alternatively, you can use raw bytes. expected_return_code Defaults to 0 . If the return code of your command is anything else, the action is considered failed. You can also specify a list, set or tuple and the action is considered failed if the command's return code is not contained in that enumeration. You can also set this to None and any return code will be accepted. expected_stdout If this is given, the stdout output of the command must match the given string or the action is considered failed. expected_stderr Same as expected_stdout , but with stderr. interactive If set to True , this action will be skipped in non-interactive mode. If set to False , this action will always be executed without asking (even in interactive mode). Defaults to None . Think hard before setting this to False . People might assume that interactive mode won't do anything without their consent.","title":"action"},{"location":"items/action/#actions","text":"Actions will be run on every bw apply . They differ from regular items in that they cannot be \"correct\" in the first place. They can only succeed or fail. actions = { 'check_if_its_still_linux': { 'command': \"uname\", 'expected_return_code': 0, 'expected_stdout': \"Linux\\n\", }, }","title":"Actions"},{"location":"items/action/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/action/#command","text":"The only required attribute. This is the command that will be run on the node with root privileges.","title":"command"},{"location":"items/action/#data_stdin","text":"You can pipe data directly to the command running on the node. To do so, use this attribute. If it's a string or unicode object, it will always be encoded as UTF-8. Alternatively, you can use raw bytes.","title":"data_stdin"},{"location":"items/action/#expected_return_code","text":"Defaults to 0 . If the return code of your command is anything else, the action is considered failed. You can also specify a list, set or tuple and the action is considered failed if the command's return code is not contained in that enumeration. You can also set this to None and any return code will be accepted.","title":"expected_return_code"},{"location":"items/action/#expected_stdout","text":"If this is given, the stdout output of the command must match the given string or the action is considered failed.","title":"expected_stdout"},{"location":"items/action/#expected_stderr","text":"Same as expected_stdout , but with stderr.","title":"expected_stderr"},{"location":"items/action/#interactive","text":"If set to True , this action will be skipped in non-interactive mode. If set to False , this action will always be executed without asking (even in interactive mode). Defaults to None . Think hard before setting this to False . People might assume that interactive mode won't do anything without their consent.","title":"interactive"},{"location":"items/dconf/","text":"dconf items dconf = { \"username/path/to/dconf/setting\": { \"value\": \"some valid settings option\", \"reset\": False, }, } Attribute reference See also: The list of generic builtin item attributes Due to how dconf works, it is currenty required to have a running dbus session when this item is changed. The easiest way to achive this is by logging in to this user in the GUI. value The value you want the setting to be set to. Must be of type str, int, list, set. Sets will get sorted prior to being set on the system. reset If set to True , resets the setting to its default value. If set, value will get ignored.","title":"dconf"},{"location":"items/dconf/#dconf-items","text":"dconf = { \"username/path/to/dconf/setting\": { \"value\": \"some valid settings option\", \"reset\": False, }, }","title":"dconf items"},{"location":"items/dconf/#attribute-reference","text":"See also: The list of generic builtin item attributes Due to how dconf works, it is currenty required to have a running dbus session when this item is changed. The easiest way to achive this is by logging in to this user in the GUI.","title":"Attribute reference"},{"location":"items/dconf/#value","text":"The value you want the setting to be set to. Must be of type str, int, list, set. Sets will get sorted prior to being set on the system.","title":"value"},{"location":"items/dconf/#reset","text":"If set to True , resets the setting to its default value. If set, value will get ignored.","title":"reset"},{"location":"items/directory/","text":"Directory items directories = { \"/path/to/directory\": { \"mode\": \"0755\", \"owner\": \"root\", \"group\": \"root\", }, } Attribute reference See also: The list of generic builtin item attributes group Name of the group this directory belongs to. Defaults to 'root' . Set to None if you don't want BundleWrap to change whatever is set on the node. mode Directory mode as returned by stat -c %a <directory> . Defaults to 755 . Set to None if you don't want BundleWrap to change whatever is set on the node. owner Username of the directory's owner. Defaults to 'root' . Set to None if you don't want BundleWrap to change whatever is set on the node. purge Set this to True to remove everything from this directory that is not managed by BundleWrap. Defaults to False .","title":"directory"},{"location":"items/directory/#directory-items","text":"directories = { \"/path/to/directory\": { \"mode\": \"0755\", \"owner\": \"root\", \"group\": \"root\", }, }","title":"Directory items"},{"location":"items/directory/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/directory/#group","text":"Name of the group this directory belongs to. Defaults to 'root' . Set to None if you don't want BundleWrap to change whatever is set on the node.","title":"group"},{"location":"items/directory/#mode","text":"Directory mode as returned by stat -c %a <directory> . Defaults to 755 . Set to None if you don't want BundleWrap to change whatever is set on the node.","title":"mode"},{"location":"items/directory/#owner","text":"Username of the directory's owner. Defaults to 'root' . Set to None if you don't want BundleWrap to change whatever is set on the node.","title":"owner"},{"location":"items/directory/#purge","text":"Set this to True to remove everything from this directory that is not managed by BundleWrap. Defaults to False .","title":"purge"},{"location":"items/file/","text":"File items Manage regular files. files = { \"/path/to/file\": { \"mode\": \"0644\", \"owner\": \"root\", \"group\": \"root\", \"content_type\": \"mako\", \"encoding\": \"utf-8\", \"source\": \"my_template\", }, } Attribute reference See also: The list of generic builtin item attributes content May be used instead of source to provide file content without a template file. content_type How the file pointed to by source or the string given to content should be interpreted. Value Effect any only cares about file owner, group, and mode base64 content is decoded from base64 download file will be downloaded from the URL specified in source binary file is uploaded verbatim, no content processing occurs jinja2 content is interpreted by the Jinja2 template engine mako content is interpreted by the Mako template engine text (default) will be read and diffed as UTF-8, but offers no template logic context Only used with Mako and Jinja2 templates. The values of this dictionary will be available from within the template as variables named after the respective keys. delete When set to True , the path of this file will be removed. It doesn't matter if there is not a file but a directory or something else at this path. When using delete , no other attributes are allowed. download_timeout Only valid if content_type is set to download . This value can be set to a number of seconds after which an error is thrown if the remote server no longer provides a response. This does NOT limit the total duration of the download. Defaults to 60.0 . encoding Encoding of the target file. Note that this applies to the remote file only, your template is still conveniently written in UTF-8 and will be converted by BundleWrap. Defaults to \"utf-8\". Other possible values (e.g. \"latin-1\") can be found here . Only allowed with content_type jinja2 , mako , or text . group Name of the group this file belongs to. Defaults to 'root' . Set to None if you don't want BundleWrap to change whatever is set on the node. If group is set to None and the file does not exist yet, group will be the primary group of the ssh user. mode File mode as returned by stat -c %a <file> . Defaults to 644 . Set to None if you don't want BundleWrap to change whatever is set on the node. If mode is set to None and the file does not exist yet, mode will be 0644 . owner Username of the file's owner. Defaults to 'root' . Set to None if you don't want BundleWrap to change whatever is set on the node. If owner is set to None and the file does not exist yet, owner will be the ssh user. source File name of the file template. If this says my_template , BundleWrap will look in data/my_bundle/files/my_template and then bundles/my_bundle/files/my_template . Most of the time, you will want to put config templates into the latter directory. The data/ subdirectory is meant for files that are very specific to your infrastructure (e.g. DNS zone files). This separation allows you to write your bundles in a generic way so that they could be open-sourced and shared with other people. Defaults to the filename of this item (e.g. foo.conf when this item is /etc/foo.conf ). See also: Writing file templates If using 'content_type': 'download' , this specifies the URL from which the file will be downloaded. The download is done on the machine running bw and then uploaded to the node, so the node doesn't need to have access to the URL. content_hash Only valid if content_type is set to download . Specifies a sha1sum to compare the downloaded file to. If set, the file will only be downloaded if the remote hash does not match. Hash will be verified after downloading and after uploading to the node. If not set, bundlewrap will always download the file, then compare the sha1sum of the downloaded file to the one currently on the node. verify_with This can be used to run external validation commands on a file before it is applied to a node. The file is verified locally on the machine running BundleWrap. Verification is considered successful if the exit code of the verification command is 0. Use {} as a placeholder for the shell-quoted path to the temporary file. Here is an example for verifying sudoers files: visudo -cf {} Keep in mind that all team members will have to have the verification command installed on their machines. test_with Same as verify_with , but called when running bw test . You may want to use this if you don't want all your team members to have to have a large suite of tools installed, but still want to verify file integrity with another tool. The file is verified locally on the machine running BundleWrap. Verification is considered successful if the exit code of the verification command is 0. Use {} as a placeholder for the shell-quoted path to the temporary file. Please note that bw test will call both verify_with and test_with , so there's no need to set both.","title":"file"},{"location":"items/file/#file-items","text":"Manage regular files. files = { \"/path/to/file\": { \"mode\": \"0644\", \"owner\": \"root\", \"group\": \"root\", \"content_type\": \"mako\", \"encoding\": \"utf-8\", \"source\": \"my_template\", }, }","title":"File items"},{"location":"items/file/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/file/#content","text":"May be used instead of source to provide file content without a template file.","title":"content"},{"location":"items/file/#content_type","text":"How the file pointed to by source or the string given to content should be interpreted. Value Effect any only cares about file owner, group, and mode base64 content is decoded from base64 download file will be downloaded from the URL specified in source binary file is uploaded verbatim, no content processing occurs jinja2 content is interpreted by the Jinja2 template engine mako content is interpreted by the Mako template engine text (default) will be read and diffed as UTF-8, but offers no template logic","title":"content_type"},{"location":"items/file/#context","text":"Only used with Mako and Jinja2 templates. The values of this dictionary will be available from within the template as variables named after the respective keys.","title":"context"},{"location":"items/file/#delete","text":"When set to True , the path of this file will be removed. It doesn't matter if there is not a file but a directory or something else at this path. When using delete , no other attributes are allowed.","title":"delete"},{"location":"items/file/#download_timeout","text":"Only valid if content_type is set to download . This value can be set to a number of seconds after which an error is thrown if the remote server no longer provides a response. This does NOT limit the total duration of the download. Defaults to 60.0 .","title":"download_timeout"},{"location":"items/file/#encoding","text":"Encoding of the target file. Note that this applies to the remote file only, your template is still conveniently written in UTF-8 and will be converted by BundleWrap. Defaults to \"utf-8\". Other possible values (e.g. \"latin-1\") can be found here . Only allowed with content_type jinja2 , mako , or text .","title":"encoding"},{"location":"items/file/#group","text":"Name of the group this file belongs to. Defaults to 'root' . Set to None if you don't want BundleWrap to change whatever is set on the node. If group is set to None and the file does not exist yet, group will be the primary group of the ssh user.","title":"group"},{"location":"items/file/#mode","text":"File mode as returned by stat -c %a <file> . Defaults to 644 . Set to None if you don't want BundleWrap to change whatever is set on the node. If mode is set to None and the file does not exist yet, mode will be 0644 .","title":"mode"},{"location":"items/file/#owner","text":"Username of the file's owner. Defaults to 'root' . Set to None if you don't want BundleWrap to change whatever is set on the node. If owner is set to None and the file does not exist yet, owner will be the ssh user.","title":"owner"},{"location":"items/file/#source","text":"File name of the file template. If this says my_template , BundleWrap will look in data/my_bundle/files/my_template and then bundles/my_bundle/files/my_template . Most of the time, you will want to put config templates into the latter directory. The data/ subdirectory is meant for files that are very specific to your infrastructure (e.g. DNS zone files). This separation allows you to write your bundles in a generic way so that they could be open-sourced and shared with other people. Defaults to the filename of this item (e.g. foo.conf when this item is /etc/foo.conf ). See also: Writing file templates If using 'content_type': 'download' , this specifies the URL from which the file will be downloaded. The download is done on the machine running bw and then uploaded to the node, so the node doesn't need to have access to the URL.","title":"source"},{"location":"items/file/#content_hash","text":"Only valid if content_type is set to download . Specifies a sha1sum to compare the downloaded file to. If set, the file will only be downloaded if the remote hash does not match. Hash will be verified after downloading and after uploading to the node. If not set, bundlewrap will always download the file, then compare the sha1sum of the downloaded file to the one currently on the node.","title":"content_hash"},{"location":"items/file/#verify_with","text":"This can be used to run external validation commands on a file before it is applied to a node. The file is verified locally on the machine running BundleWrap. Verification is considered successful if the exit code of the verification command is 0. Use {} as a placeholder for the shell-quoted path to the temporary file. Here is an example for verifying sudoers files: visudo -cf {} Keep in mind that all team members will have to have the verification command installed on their machines.","title":"verify_with"},{"location":"items/file/#test_with","text":"Same as verify_with , but called when running bw test . You may want to use this if you don't want all your team members to have to have a large suite of tools installed, but still want to verify file integrity with another tool. The file is verified locally on the machine running BundleWrap. Verification is considered successful if the exit code of the verification command is 0. Use {} as a placeholder for the shell-quoted path to the temporary file. Please note that bw test will call both verify_with and test_with , so there's no need to set both.","title":"test_with"},{"location":"items/git_deploy/","text":"Deploying from git The git_deploy item lets you deploy the contents of a git repository to a node - without requiring the node to have access to that repository or exposing the .git/ directory to the node. directories = { # git_deploy will not create this by itself \"/var/tmp/example\": {}, } git_deploy = { \"/var/tmp/example\": { 'repo': \"example\", 'rev': \"master\", 'use_xattrs': True, }, } git_deploy items will only upload a tarball with the data from the git repo, no part of the git history is leaked to the node. Requires git to be installed on the machine running BundleWrap. git_deploy_repos Put this in a file called git_deploy_repos in your repository root: example: /Users/jdoe/Projects/example This file should also be added to your .gitignore if you are sharing that repo with a team. Each team member must provide a mapping of the repo name used in the bundle (\"example\" in this case) to a local filesystem path with a git repository. It is each user's responsibility to make sure the clone in that location is up to date. Attribute reference See also: The list of generic builtin item attributes repo The short name of a repo as it appears in git_deploy_repos . Alternatively, it can point directly to a git URL: git_deploy = { \"/var/tmp/example\": { 'repo': \"https://github.com/bundlewrap/bundlewrap.git\", [...] }, } Note however that this has a performance penalty, as a new clone of that repo has to be made on every run of BundleWrap. (See section \"Environment variables\" below.) rev The rev attribute can contain anything git rev-parse can resolve into a commit hash (branch names, tags, first few characters of full commit hash). Note that you should probably use tags here. Never use HEAD (use a branch name like 'master' instead). use_xattrs BundleWrap needs to store the deployed commit hash on the node. The use_xattrs attribute controls how this is done. If set to True , the attr command on the node is used to store the hash as an extended file system attribute. Since attr might not be installed on the node, the default is to place a dotfile in the target directory instead (keep that in mind when deploying websites etc.). Environment variables BW_GIT_DEPLOY_CACHE This only affects repositories for which a URL has been specified. With this env var unset, BundleWrap will clone repos to a temporary directory. This is done once per BundleWrap process and removed automatically when the process terminates. If you manually launch multiple parallel processes of bw , each of those will clone the git repo. This can create significant overhead, since they all create redundant copies. You can set BW_GIT_DEPLOY_CACHE to an absolute path: All the bw processes will use it as a shared cache. Note: It is not wise to use this option on your workstation. BundleWrap will only ever clone repos, not pull or delete them. This variable is meant as a temporary cache, for example in CI builds, and you will have to clean it up yourself.","title":"git_deploy"},{"location":"items/git_deploy/#deploying-from-git","text":"The git_deploy item lets you deploy the contents of a git repository to a node - without requiring the node to have access to that repository or exposing the .git/ directory to the node. directories = { # git_deploy will not create this by itself \"/var/tmp/example\": {}, } git_deploy = { \"/var/tmp/example\": { 'repo': \"example\", 'rev': \"master\", 'use_xattrs': True, }, } git_deploy items will only upload a tarball with the data from the git repo, no part of the git history is leaked to the node. Requires git to be installed on the machine running BundleWrap.","title":"Deploying from git"},{"location":"items/git_deploy/#git_deploy_repos","text":"Put this in a file called git_deploy_repos in your repository root: example: /Users/jdoe/Projects/example This file should also be added to your .gitignore if you are sharing that repo with a team. Each team member must provide a mapping of the repo name used in the bundle (\"example\" in this case) to a local filesystem path with a git repository. It is each user's responsibility to make sure the clone in that location is up to date.","title":"git_deploy_repos"},{"location":"items/git_deploy/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/git_deploy/#repo","text":"The short name of a repo as it appears in git_deploy_repos . Alternatively, it can point directly to a git URL: git_deploy = { \"/var/tmp/example\": { 'repo': \"https://github.com/bundlewrap/bundlewrap.git\", [...] }, } Note however that this has a performance penalty, as a new clone of that repo has to be made on every run of BundleWrap. (See section \"Environment variables\" below.)","title":"repo"},{"location":"items/git_deploy/#rev","text":"The rev attribute can contain anything git rev-parse can resolve into a commit hash (branch names, tags, first few characters of full commit hash). Note that you should probably use tags here. Never use HEAD (use a branch name like 'master' instead).","title":"rev"},{"location":"items/git_deploy/#use_xattrs","text":"BundleWrap needs to store the deployed commit hash on the node. The use_xattrs attribute controls how this is done. If set to True , the attr command on the node is used to store the hash as an extended file system attribute. Since attr might not be installed on the node, the default is to place a dotfile in the target directory instead (keep that in mind when deploying websites etc.).","title":"use_xattrs"},{"location":"items/git_deploy/#environment-variables","text":"","title":"Environment variables"},{"location":"items/git_deploy/#bw_git_deploy_cache","text":"This only affects repositories for which a URL has been specified. With this env var unset, BundleWrap will clone repos to a temporary directory. This is done once per BundleWrap process and removed automatically when the process terminates. If you manually launch multiple parallel processes of bw , each of those will clone the git repo. This can create significant overhead, since they all create redundant copies. You can set BW_GIT_DEPLOY_CACHE to an absolute path: All the bw processes will use it as a shared cache. Note: It is not wise to use this option on your workstation. BundleWrap will only ever clone repos, not pull or delete them. This variable is meant as a temporary cache, for example in CI builds, and you will have to clean it up yourself.","title":"BW_GIT_DEPLOY_CACHE"},{"location":"items/group/","text":"Group items Manages system groups. Group members are managed through the user item . groups = { \"acme\": { \"gid\": 2342, }, } Attribute reference See also: The list of generic builtin item attributes delete When set to True , this group will be removed from the system. When using delete , no other attributes are allowed. gid Numerical ID of the group.","title":"group"},{"location":"items/group/#group-items","text":"Manages system groups. Group members are managed through the user item . groups = { \"acme\": { \"gid\": 2342, }, }","title":"Group items"},{"location":"items/group/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/group/#delete","text":"When set to True , this group will be removed from the system. When using delete , no other attributes are allowed.","title":"delete"},{"location":"items/group/#gid","text":"Numerical ID of the group.","title":"gid"},{"location":"items/k8s/","text":"Kubernetes items Support for Kubernetes is experimental at this time. Backwards-incompatible changes may happen at any time. See also: Guide to Kubernetes Manage resources in Kubernetes clusters. k8s_namespaces = { \"my-app\": { 'manifest': { 'apiVersion': \"v1\", }, }, \"my-previous-app\": {'delete': True}, } k8s_deployments = { \"my-app/my-deployment\": { 'manifest': { ... }, }, } Note that the names of all items in a namespace must be prefixed with the name of their namespace and a forward slash / . Resource items will automatically depend on their namespace if you defined it. Resource types Resource type Bundle attribute Cluster Role k8s_clusterroles Cluster Role Binding k8s_clusterrolebindings Config Map k8s_configmaps Cron Job k8s_cronjobs Custom Resource Definition k8s_crd Daemon Set k8s_daemonsets Deployment k8s_deployments Ingress k8s_ingresses Namespace k8s_namespaces Network Policy k8s_networkpolicies Persistent Volume Claim k8s_pvc Role k8s_roles Role Binding k8s_rolebindings Service k8s_services Service Account k8s_serviceaccounts Secret k8s_secrets StatefulSet k8s_statefulsets (any) k8s_raw You can define Custom Resources like this: k8s_crd = { \"custom-thing\": { 'manifest': { 'apiVersion': \"apiextensions.k8s.io/v1beta1\", 'spec': { 'names': { 'kind': \"CustomThing\", }, }, }, }, } k8s_raw = { \"foo/CustomThing/baz\": { 'manifest': { 'apiVersion': \"example.com/v1\", }, }, } The special k8s_raw items can also be used to create resources that BundleWrap does not support natively: k8s_raw = { \"foo/HorizontalPodAutoscaler/baz\": { 'manifest': { 'apiVersion': \"autoscaling/v2beta1\", }, }, } Resources outside any namespace can be created with k8s_raw by omitting the namespace in the item name (so that the name starts with / ). Attribute reference See also: The list of generic builtin item attributes context Only used with Mako and Jinja2 manifests (see manifest_processing below). The values of this dictionary will be available from within the template as variables named after the respective keys. delete Set this to True to have the resource removed. manifest The resource definition (as defined in the Kubernetes API ) formatted as a Python dictionary (will be converted to JSON and passed to kubectl apply ). Mutually exclusive with manifest_file . manifest_file Filename of the resource definition relative to the manifests subdirectory of your bundle. Filenames must end in .yaml , .yml , or .json to indicate file format. Mutually exclusive with manifest . manifest_processor Set this to jinja2 or mako if you want to use a template engine to process your manifest_file . Defaults to None .","title":"k8s_*"},{"location":"items/k8s/#kubernetes-items","text":"Support for Kubernetes is experimental at this time. Backwards-incompatible changes may happen at any time. See also: Guide to Kubernetes Manage resources in Kubernetes clusters. k8s_namespaces = { \"my-app\": { 'manifest': { 'apiVersion': \"v1\", }, }, \"my-previous-app\": {'delete': True}, } k8s_deployments = { \"my-app/my-deployment\": { 'manifest': { ... }, }, } Note that the names of all items in a namespace must be prefixed with the name of their namespace and a forward slash / . Resource items will automatically depend on their namespace if you defined it.","title":"Kubernetes items"},{"location":"items/k8s/#resource-types","text":"Resource type Bundle attribute Cluster Role k8s_clusterroles Cluster Role Binding k8s_clusterrolebindings Config Map k8s_configmaps Cron Job k8s_cronjobs Custom Resource Definition k8s_crd Daemon Set k8s_daemonsets Deployment k8s_deployments Ingress k8s_ingresses Namespace k8s_namespaces Network Policy k8s_networkpolicies Persistent Volume Claim k8s_pvc Role k8s_roles Role Binding k8s_rolebindings Service k8s_services Service Account k8s_serviceaccounts Secret k8s_secrets StatefulSet k8s_statefulsets (any) k8s_raw You can define Custom Resources like this: k8s_crd = { \"custom-thing\": { 'manifest': { 'apiVersion': \"apiextensions.k8s.io/v1beta1\", 'spec': { 'names': { 'kind': \"CustomThing\", }, }, }, }, } k8s_raw = { \"foo/CustomThing/baz\": { 'manifest': { 'apiVersion': \"example.com/v1\", }, }, } The special k8s_raw items can also be used to create resources that BundleWrap does not support natively: k8s_raw = { \"foo/HorizontalPodAutoscaler/baz\": { 'manifest': { 'apiVersion': \"autoscaling/v2beta1\", }, }, } Resources outside any namespace can be created with k8s_raw by omitting the namespace in the item name (so that the name starts with / ).","title":"Resource types"},{"location":"items/k8s/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/k8s/#context","text":"Only used with Mako and Jinja2 manifests (see manifest_processing below). The values of this dictionary will be available from within the template as variables named after the respective keys.","title":"context"},{"location":"items/k8s/#delete","text":"Set this to True to have the resource removed.","title":"delete"},{"location":"items/k8s/#manifest","text":"The resource definition (as defined in the Kubernetes API ) formatted as a Python dictionary (will be converted to JSON and passed to kubectl apply ). Mutually exclusive with manifest_file .","title":"manifest"},{"location":"items/k8s/#manifest_file","text":"Filename of the resource definition relative to the manifests subdirectory of your bundle. Filenames must end in .yaml , .yml , or .json to indicate file format. Mutually exclusive with manifest .","title":"manifest_file"},{"location":"items/k8s/#manifest_processor","text":"Set this to jinja2 or mako if you want to use a template engine to process your manifest_file . Defaults to None .","title":"manifest_processor"},{"location":"items/pkg_apk/","text":"apk package items Handles packages installed by apk on Alpine-based systems. pkg_apk = { \"foopkg\": { \"installed\": True, # default }, \"bar\": { \"installed\": False, }, } Attribute reference See also: The list of generic builtin item attributes installed True when the package is expected to be present on the system; False if it should be removed.","title":"pkg_apk"},{"location":"items/pkg_apk/#apk-package-items","text":"Handles packages installed by apk on Alpine-based systems. pkg_apk = { \"foopkg\": { \"installed\": True, # default }, \"bar\": { \"installed\": False, }, }","title":"apk package items"},{"location":"items/pkg_apk/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/pkg_apk/#installed","text":"True when the package is expected to be present on the system; False if it should be removed.","title":"installed"},{"location":"items/pkg_apt/","text":"APT package items Handles packages installed by apt-get on Debian-based systems. pkg_apt = { \"foopkg\": { \"installed\": True, # default }, \"bar_i386\": { # i386 multiarch variant of the \"bar\" package \"installed\": False, }, \"awesome-daemon\": { \"when_creating\": { \"start_service\": False, }, }, } Attribute reference See also: The list of generic builtin item attributes installed True when the package is expected to be present on the system; False if it should be purged. when_creating These attributes are only enforced during the creation of the item on the node (in this case this means when a package is installed). They are ignored in subsequent runs of bw apply . start_service By default, daemons will be auto-started on systems like Debian or Ubuntu. This happens right after the package has been installed. You might want to set start_service to False to avoid this. This might be necessary if BundleWrap must place some more config files on the node before a daemon can actually be started.","title":"pkg_apt"},{"location":"items/pkg_apt/#apt-package-items","text":"Handles packages installed by apt-get on Debian-based systems. pkg_apt = { \"foopkg\": { \"installed\": True, # default }, \"bar_i386\": { # i386 multiarch variant of the \"bar\" package \"installed\": False, }, \"awesome-daemon\": { \"when_creating\": { \"start_service\": False, }, }, }","title":"APT package items"},{"location":"items/pkg_apt/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/pkg_apt/#installed","text":"True when the package is expected to be present on the system; False if it should be purged.","title":"installed"},{"location":"items/pkg_apt/#when_creating","text":"These attributes are only enforced during the creation of the item on the node (in this case this means when a package is installed). They are ignored in subsequent runs of bw apply .","title":"when_creating"},{"location":"items/pkg_apt/#start_service","text":"By default, daemons will be auto-started on systems like Debian or Ubuntu. This happens right after the package has been installed. You might want to set start_service to False to avoid this. This might be necessary if BundleWrap must place some more config files on the node before a daemon can actually be started.","title":"start_service"},{"location":"items/pkg_dnf/","text":"dnf package items Handles packages installed by dnf on RPM-based systems. pkg_dnf = { \"foopkg\": { \"installed\": True, # default }, \"bar\": { \"installed\": False, }, } Attribute reference See also: The list of generic builtin item attributes installed True when the package is expected to be present on the system; False if it should be removed.","title":"pkg_dnf"},{"location":"items/pkg_dnf/#dnf-package-items","text":"Handles packages installed by dnf on RPM-based systems. pkg_dnf = { \"foopkg\": { \"installed\": True, # default }, \"bar\": { \"installed\": False, }, }","title":"dnf package items"},{"location":"items/pkg_dnf/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/pkg_dnf/#installed","text":"True when the package is expected to be present on the system; False if it should be removed.","title":"installed"},{"location":"items/pkg_freebsd/","text":"FreeBSD package items Handles packages installed by pkg on FreeBSD systems. pkg_freebsd = { \"foo\": { \"installed\": True, # default }, \"bar\": { \"installed\": True, \"version\": \"1.0\", }, \"baz\": { \"installed\": False, }, } Attribute reference See also: The list of generic builtin item attributes installed True when the package is expected to be present on the system; False if it should be purged. version Optional version string. Can be used to select one specific version of a package. Ignored when installed is False .","title":"pkg_freebsd"},{"location":"items/pkg_freebsd/#freebsd-package-items","text":"Handles packages installed by pkg on FreeBSD systems. pkg_freebsd = { \"foo\": { \"installed\": True, # default }, \"bar\": { \"installed\": True, \"version\": \"1.0\", }, \"baz\": { \"installed\": False, }, }","title":"FreeBSD package items"},{"location":"items/pkg_freebsd/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/pkg_freebsd/#installed","text":"True when the package is expected to be present on the system; False if it should be purged.","title":"installed"},{"location":"items/pkg_freebsd/#version","text":"Optional version string. Can be used to select one specific version of a package. Ignored when installed is False .","title":"version"},{"location":"items/pkg_openbsd/","text":"OpenBSD package items Handles packages installed by pkg_add on OpenBSD systems. pkg_openbsd = { \"foo\": { \"installed\": True, # default }, \"bar\": { \"installed\": True, \"version\": \"1.0\", }, \"baz\": { \"installed\": False, }, \"qux\": { \"flavor\": \"no_x11\", }, } Attribute reference See also: The list of generic builtin item attributes installed True when the package is expected to be present on the system; False if it should be purged. flavor Optional, defaults to the \"normal\" flavor. Can be used together with version . Ignored when installed is False . version Optional version string. Can be used to select one specific version of a package. Can be used together with flavor . Ignored when installed is False .","title":"pkg_openbsd"},{"location":"items/pkg_openbsd/#openbsd-package-items","text":"Handles packages installed by pkg_add on OpenBSD systems. pkg_openbsd = { \"foo\": { \"installed\": True, # default }, \"bar\": { \"installed\": True, \"version\": \"1.0\", }, \"baz\": { \"installed\": False, }, \"qux\": { \"flavor\": \"no_x11\", }, }","title":"OpenBSD package items"},{"location":"items/pkg_openbsd/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/pkg_openbsd/#installed","text":"True when the package is expected to be present on the system; False if it should be purged.","title":"installed"},{"location":"items/pkg_openbsd/#flavor","text":"Optional, defaults to the \"normal\" flavor. Can be used together with version . Ignored when installed is False .","title":"flavor"},{"location":"items/pkg_openbsd/#version","text":"Optional version string. Can be used to select one specific version of a package. Can be used together with flavor . Ignored when installed is False .","title":"version"},{"location":"items/pkg_opkg/","text":"opkg package items Handles packages installed by opkg on OpenWRT/LEDE. pkg_opkg = { \"foopkg\": { \"installed\": True, # default }, \"bar\": { \"installed\": False, }, } Attribute reference See also: The list of generic builtin item attributes installed True when the package is expected to be present on the system; False if it should be removed.","title":"pkg_opkg"},{"location":"items/pkg_opkg/#opkg-package-items","text":"Handles packages installed by opkg on OpenWRT/LEDE. pkg_opkg = { \"foopkg\": { \"installed\": True, # default }, \"bar\": { \"installed\": False, }, }","title":"opkg package items"},{"location":"items/pkg_opkg/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/pkg_opkg/#installed","text":"True when the package is expected to be present on the system; False if it should be removed.","title":"installed"},{"location":"items/pkg_pacman/","text":"Pacman package items Handles packages installed by pacman (e.g. Arch Linux). pkg_pacman = { \"foopkg\": { \"installed\": True, # default }, \"bar\": { \"installed\": False, }, \"somethingelse\": { \"tarball\": \"something-1.0.pkg.tar.gz\", } } System updates on Arch Linux should always be performed manually and with great care. Thus, this item type installs packages with a simple pacman -S $pkgname instead of the commonly recommended pacman -Syu $pkgname . You should manually do a full system update before installing new packages via BundleWrap! Attribute reference See also: The list of generic builtin item attributes installed True when the package is expected to be present on the system; False if this package and all dependencies that are no longer needed should be removed. tarball Upload a local file to the node and install it using pacman -U . The value of tarball must point to a file relative to the pkg_pacman subdirectory of the current bundle.","title":"pkg_pacman"},{"location":"items/pkg_pacman/#pacman-package-items","text":"Handles packages installed by pacman (e.g. Arch Linux). pkg_pacman = { \"foopkg\": { \"installed\": True, # default }, \"bar\": { \"installed\": False, }, \"somethingelse\": { \"tarball\": \"something-1.0.pkg.tar.gz\", } } System updates on Arch Linux should always be performed manually and with great care. Thus, this item type installs packages with a simple pacman -S $pkgname instead of the commonly recommended pacman -Syu $pkgname . You should manually do a full system update before installing new packages via BundleWrap!","title":"Pacman package items"},{"location":"items/pkg_pacman/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/pkg_pacman/#installed","text":"True when the package is expected to be present on the system; False if this package and all dependencies that are no longer needed should be removed.","title":"installed"},{"location":"items/pkg_pacman/#tarball","text":"Upload a local file to the node and install it using pacman -U . The value of tarball must point to a file relative to the pkg_pacman subdirectory of the current bundle.","title":"tarball"},{"location":"items/pkg_pamac/","text":"Pamac package items Handles packages installed by pacman (e.g. Arch Linux) and pamac . Uses pamac to install, build and remove packages. Needs pacman to determine if a package is installed. Pacman is only used to read information from the node, all action is handeled by pamac . pkg_pamac = { \"foopkg\": { \"installed\": True, # default }, \"bar\": { \"installed\": False, }, \"somethingelse\": { \"when_creating\": { \"aur\": True, # installs package from AUR instead of official repos. Defaults to `False` }, }. } System updates on Arch Linux should always be performed manually and with great care. Thus, this item type installs packages with pamac install --no-upgrade $pkgname . You should manually do a full system update before installing new packages via BundleWrap! Attribute reference See also: The list of generic builtin item attributes installed True when the package is expected to be present on the system; False if this package and all dependencies that are no longer needed should be removed. aur True when the package should be installed from AUR; False if package should be installed from official sources. Defaults to False . This attribute will only be read when creating the item on the node, e.g. when the desired package will be installed for the first time. In subsequent runs, this item will be ignored. See when_creating documentation","title":"pkg_pamac"},{"location":"items/pkg_pamac/#pamac-package-items","text":"Handles packages installed by pacman (e.g. Arch Linux) and pamac . Uses pamac to install, build and remove packages. Needs pacman to determine if a package is installed. Pacman is only used to read information from the node, all action is handeled by pamac . pkg_pamac = { \"foopkg\": { \"installed\": True, # default }, \"bar\": { \"installed\": False, }, \"somethingelse\": { \"when_creating\": { \"aur\": True, # installs package from AUR instead of official repos. Defaults to `False` }, }. } System updates on Arch Linux should always be performed manually and with great care. Thus, this item type installs packages with pamac install --no-upgrade $pkgname . You should manually do a full system update before installing new packages via BundleWrap!","title":"Pamac package items"},{"location":"items/pkg_pamac/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/pkg_pamac/#installed","text":"True when the package is expected to be present on the system; False if this package and all dependencies that are no longer needed should be removed.","title":"installed"},{"location":"items/pkg_pamac/#aur","text":"True when the package should be installed from AUR; False if package should be installed from official sources. Defaults to False . This attribute will only be read when creating the item on the node, e.g. when the desired package will be installed for the first time. In subsequent runs, this item will be ignored. See when_creating documentation","title":"aur"},{"location":"items/pkg_pip/","text":"pip package items Handles Python packages installed by pip . Note that you can use the pip_command node attribute to use pip3 . pkg_pip = { \"foo\": { \"installed\": True, # default \"version\": \"1.0\", # optional }, \"bar\": { \"installed\": False, }, \"/path/to/virtualenv/foo\": { # will install foo in the virtualenv at /path/to/virtualenv }, } Attribute reference See also: The list of generic builtin item attributes break_system_packages True if you want BundleWrap to add the --break-system-packages flag. Refer to https://www.debian.org/releases/bookworm/amd64/release-notes/ch-information.en.html#python3-pep-668 . Default is False . This feature is temporary and usage is discouraged . It might be removed from future BundleWrap versions. installed True when the package is expected to be present on the system; False if it should be removed. version Force the given exact version to be installed. You can only specify a single version here, selectors like >=1.0 are NOT supported. If it's not given, the latest version will be installed initially, but (like the other package items) upgrades will NOT be installed.","title":"pkg_pip"},{"location":"items/pkg_pip/#pip-package-items","text":"Handles Python packages installed by pip . Note that you can use the pip_command node attribute to use pip3 . pkg_pip = { \"foo\": { \"installed\": True, # default \"version\": \"1.0\", # optional }, \"bar\": { \"installed\": False, }, \"/path/to/virtualenv/foo\": { # will install foo in the virtualenv at /path/to/virtualenv }, }","title":"pip package items"},{"location":"items/pkg_pip/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/pkg_pip/#break_system_packages","text":"True if you want BundleWrap to add the --break-system-packages flag. Refer to https://www.debian.org/releases/bookworm/amd64/release-notes/ch-information.en.html#python3-pep-668 . Default is False . This feature is temporary and usage is discouraged . It might be removed from future BundleWrap versions.","title":"break_system_packages"},{"location":"items/pkg_pip/#installed","text":"True when the package is expected to be present on the system; False if it should be removed.","title":"installed"},{"location":"items/pkg_pip/#version","text":"Force the given exact version to be installed. You can only specify a single version here, selectors like >=1.0 are NOT supported. If it's not given, the latest version will be installed initially, but (like the other package items) upgrades will NOT be installed.","title":"version"},{"location":"items/pkg_snap/","text":"snap package items Handles packages installed by snap command. pkg_snap = { \"foopkg\": { \"installed\": True, # default }, \"bar\": { \"installed\": False, }, } Attribute reference See also: The list of generic builtin item attributes installed True when the package is expected to be present on the system; False if it should be removed.","title":"pkg_snap"},{"location":"items/pkg_snap/#snap-package-items","text":"Handles packages installed by snap command. pkg_snap = { \"foopkg\": { \"installed\": True, # default }, \"bar\": { \"installed\": False, }, }","title":"snap package items"},{"location":"items/pkg_snap/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/pkg_snap/#installed","text":"True when the package is expected to be present on the system; False if it should be removed.","title":"installed"},{"location":"items/pkg_yum/","text":"yum package items Handles packages installed by yum on RPM-based systems. pkg_yum = { \"foopkg\": { \"installed\": True, # default }, \"bar\": { \"installed\": False, }, } Attribute reference See also: The list of generic builtin item attributes installed True when the package is expected to be present on the system; False if it should be removed.","title":"pkg_yum"},{"location":"items/pkg_yum/#yum-package-items","text":"Handles packages installed by yum on RPM-based systems. pkg_yum = { \"foopkg\": { \"installed\": True, # default }, \"bar\": { \"installed\": False, }, }","title":"yum package items"},{"location":"items/pkg_yum/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/pkg_yum/#installed","text":"True when the package is expected to be present on the system; False if it should be removed.","title":"installed"},{"location":"items/pkg_zypper/","text":"zypper package items Handles packages installed by zypper on SUSE-based systems. pkg_zypper = { \"foopkg\": { \"installed\": True, # default }, \"bar\": { \"installed\": False, }, } Attribute reference See also: The list of generic builtin item attributes installed True when the package is expected to be present on the system; False if it should be removed.","title":"pkg_zypper"},{"location":"items/pkg_zypper/#zypper-package-items","text":"Handles packages installed by zypper on SUSE-based systems. pkg_zypper = { \"foopkg\": { \"installed\": True, # default }, \"bar\": { \"installed\": False, }, }","title":"zypper package items"},{"location":"items/pkg_zypper/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/pkg_zypper/#installed","text":"True when the package is expected to be present on the system; False if it should be removed.","title":"installed"},{"location":"items/postgres_db/","text":"Postgres database items Manages Postgres databases. postgres_dbs = { \"mydatabase\": { \"owner\": \"me\", \"when_creating\": { \"encoding\": \"LATIN1\", \"collation\": \"de_DE.ISO-8859-1\", \"ctype\": \"de_DE.ISO-8859-1\", }, }, } Attribute reference See also: The list of generic builtin item attributes owner Name of the role which owns this database (defaults to \"postgres\" ). when_creating encoding, collation, and ctype By default, BundleWrap will only create a database using your default PostgreSQL template, which most likely is template1 . This means it will use the same encoding and collation that template1 uses. By specifying any of the attributes encoding , collation , or ctype , BundleWrap will instead create a new database from template0 , thus allowing you to override said database attributes. These options are creation-time only. delete True if the database should be deleted (defaults to False ).","title":"postgres_db"},{"location":"items/postgres_db/#postgres-database-items","text":"Manages Postgres databases. postgres_dbs = { \"mydatabase\": { \"owner\": \"me\", \"when_creating\": { \"encoding\": \"LATIN1\", \"collation\": \"de_DE.ISO-8859-1\", \"ctype\": \"de_DE.ISO-8859-1\", }, }, }","title":"Postgres database items"},{"location":"items/postgres_db/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/postgres_db/#owner","text":"Name of the role which owns this database (defaults to \"postgres\" ).","title":"owner"},{"location":"items/postgres_db/#when_creating","text":"","title":"when_creating"},{"location":"items/postgres_db/#encoding-collation-and-ctype","text":"By default, BundleWrap will only create a database using your default PostgreSQL template, which most likely is template1 . This means it will use the same encoding and collation that template1 uses. By specifying any of the attributes encoding , collation , or ctype , BundleWrap will instead create a new database from template0 , thus allowing you to override said database attributes. These options are creation-time only.","title":"encoding, collation, and ctype"},{"location":"items/postgres_db/#delete","text":"True if the database should be deleted (defaults to False ).","title":"delete"},{"location":"items/postgres_role/","text":"Postgres role items Manages Postgres roles. postgres_roles = { \"me\": { \"superuser\": True, \"password\": \"itsamemario\", }, } Attribute reference See also: The list of generic builtin item attributes superuser True if the role should be given superuser privileges (defaults to False ). password Plaintext password to set for this role (will be hashed using MD5). Please do not write any passwords into your bundles. This attribute is intended to be used with an external source of passwords and filled dynamically. If you don't have or want such an elaborate setup, specify passwords using the password_hash attribute instead. password_hash As an alternative to password , this allows setting the raw hash as it will be stored in Postgres' internal database. Should start with \"md5\". delete True if the role should be deleted (defaults to False ).","title":"postgres_role"},{"location":"items/postgres_role/#postgres-role-items","text":"Manages Postgres roles. postgres_roles = { \"me\": { \"superuser\": True, \"password\": \"itsamemario\", }, }","title":"Postgres role items"},{"location":"items/postgres_role/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/postgres_role/#superuser","text":"True if the role should be given superuser privileges (defaults to False ).","title":"superuser"},{"location":"items/postgres_role/#password","text":"Plaintext password to set for this role (will be hashed using MD5). Please do not write any passwords into your bundles. This attribute is intended to be used with an external source of passwords and filled dynamically. If you don't have or want such an elaborate setup, specify passwords using the password_hash attribute instead.","title":"password"},{"location":"items/postgres_role/#password_hash","text":"As an alternative to password , this allows setting the raw hash as it will be stored in Postgres' internal database. Should start with \"md5\".","title":"password_hash"},{"location":"items/postgres_role/#delete","text":"True if the role should be deleted (defaults to False ).","title":"delete"},{"location":"items/routeros/","text":"RouterOS items Manages RouterOS configuration through the API (port 8728). You can address every configuration exposed by the API by constructing the item name and attributes accordingly. If you haven't already, familiarize yourself with the CLI over SSH first. Use it as a reference when composing items in your bundles. Don't forget to set the os attribute of your node to routeros and also set the username and password attributes. routeros = { \"/ip/dns\": { \"servers\": \"8.8.8.8\", }, \"/interface/vlan?name=vlan6\": { \"vlan-id\": \"6\", \"interface\": \"bridge\", \"needs\": { \"routeros:/interface/bridge?name=bridge\", }, }, \"/interface/vlan?name=vlan7\": { \"delete\": True, }, \"/interface/vlan\": { \"purge\": { \"id-by\": \"name\", }, }, \"/interface/bridge?name=bridge\": {}, \"/interface/bridge/port?interface=ether8\": { \"bridge\": \"bridge\", \"needs\": { \"routeros:/interface/bridge?name=bridge\", }, }, \"/interface/bridge/port\": { \"purge\": { \"id-by\": \"interface\", }, }, \"/interface/bridge/vlan?vlan-ids=6\": { \"bridge\": \"bridge\", \"needs\": { \"routeros:/interface/bridge?name=bridge\", }, \"tagged\": { \"ether10\", \"ether11\", \"ether12\", }, \"untagged\": { \"ether13\", \"ether14\", \"ether15\", }, }, \"/interface/bridge/vlan\": { \"purge\": { \"id-by\": \"vlan-ids\", \"keep\": { \"dynamic\": True, }, }, }, \"/interface/bonding?name=LAG1\": { \"mode\": \"802.3ad\", \"slaves\": [\"ether2\", \"ether3\"], \"transmit-hash-policy\": \"layer-3-and-4\", }, \"/interface/bonding\": { \"purge\": { \"id-by\": \"name\", }, }, \"/system/logging?action=remote&topics=critical\": {}, } Note that when configuring an item from a list of things, item names have two parts, separated by a ? character. The first part determines which kind of item is addressed, the second part is a simple key=value query that MUST return exactly one entry. If a list has no single \"primary key\" (such as /system/logging ), use & to add more conditions. For lists of things, the purge option can be used to instruct BundleWrap to remove items it doesn't know about (see the Purging section). For example /interface/vlan addresses all VLAN interfaces (a list of things) and can be configured to purge unmanaged VLANs, whereas /interface/vlan?name=vlan7 configures a specific VLAN. Purging For any lists of things (VLAN interfaces, bonds) the purge option can be enabled: \"/interface/vlan?name=vlan6\": { \"vlan-id\": \"6\", \"interface\": \"bridge\", \"needs\": { \"routeros:/interface/bridge?name=bridge\", }, }, \"/interface/vlan\": { \"purge\": { \"id-by\": \"name\", }, }, The id-by option tells BundleWrap to identify configured items by the specified key. In the above example, BundleWrap searches for all items with item ids starting wih /interface/vlan that contain a name key. It finds /interface/vlan?name=vlan6 and assumes that only one VLAN should be configured and it should have a name of vlan6 . It will then delete any VLANs on the node not matching this selection. For different items, different selection keys are useful. For example for bridge ports, the interface key is often used: \"/interface/bridge/port?interface=ether8\": { \"bridge\": \"bridge\", \"needs\": { \"routeros:/interface/bridge?name=bridge\", }, }, \"/interface/bridge/port\": { \"purge\": { \"id-by\": \"interface\", }, }, Again, the managed items under the /interface/bridge/port path are identified by the interface key and this key is also used to select items to be purged. For some types of items, not all subitems can be deleted. For example /interface/bridge/vlan will also list dynamic VLANs which are not configured and can thus not be removed. They automatically appear/disappear with the bridge ports using them. In these cases, additional attributes can be specified in the keep option. Any item on the node that has any attribute matching the keep filter will also be retained and not purged. \"/interface/bridge/vlan\": { \"purge\": { \"id-by\": \"vlan-ids\", \"keep\": { \"dynamic\": True, }, }, }, Attribute reference See also: The list of generic builtin item attributes BundleWrap will accept any attributes for these items and pass them through to the RouterOS API. All attribute values can be passed as strings. If given as integers or booleans, BundleWrap will convert them to strings for you. If given a set, list, or tuple of strings, BundleWrap will join those strings with commas. Since comment is an internal attribute for BundleWrap, use _comment to apply the comment attribute on a RouterOS item. delete When set to True , this item will be removed from the system. When using delete , no other attributes are allowed.","title":"routeros"},{"location":"items/routeros/#routeros-items","text":"Manages RouterOS configuration through the API (port 8728). You can address every configuration exposed by the API by constructing the item name and attributes accordingly. If you haven't already, familiarize yourself with the CLI over SSH first. Use it as a reference when composing items in your bundles. Don't forget to set the os attribute of your node to routeros and also set the username and password attributes. routeros = { \"/ip/dns\": { \"servers\": \"8.8.8.8\", }, \"/interface/vlan?name=vlan6\": { \"vlan-id\": \"6\", \"interface\": \"bridge\", \"needs\": { \"routeros:/interface/bridge?name=bridge\", }, }, \"/interface/vlan?name=vlan7\": { \"delete\": True, }, \"/interface/vlan\": { \"purge\": { \"id-by\": \"name\", }, }, \"/interface/bridge?name=bridge\": {}, \"/interface/bridge/port?interface=ether8\": { \"bridge\": \"bridge\", \"needs\": { \"routeros:/interface/bridge?name=bridge\", }, }, \"/interface/bridge/port\": { \"purge\": { \"id-by\": \"interface\", }, }, \"/interface/bridge/vlan?vlan-ids=6\": { \"bridge\": \"bridge\", \"needs\": { \"routeros:/interface/bridge?name=bridge\", }, \"tagged\": { \"ether10\", \"ether11\", \"ether12\", }, \"untagged\": { \"ether13\", \"ether14\", \"ether15\", }, }, \"/interface/bridge/vlan\": { \"purge\": { \"id-by\": \"vlan-ids\", \"keep\": { \"dynamic\": True, }, }, }, \"/interface/bonding?name=LAG1\": { \"mode\": \"802.3ad\", \"slaves\": [\"ether2\", \"ether3\"], \"transmit-hash-policy\": \"layer-3-and-4\", }, \"/interface/bonding\": { \"purge\": { \"id-by\": \"name\", }, }, \"/system/logging?action=remote&topics=critical\": {}, } Note that when configuring an item from a list of things, item names have two parts, separated by a ? character. The first part determines which kind of item is addressed, the second part is a simple key=value query that MUST return exactly one entry. If a list has no single \"primary key\" (such as /system/logging ), use & to add more conditions. For lists of things, the purge option can be used to instruct BundleWrap to remove items it doesn't know about (see the Purging section). For example /interface/vlan addresses all VLAN interfaces (a list of things) and can be configured to purge unmanaged VLANs, whereas /interface/vlan?name=vlan7 configures a specific VLAN.","title":"RouterOS items"},{"location":"items/routeros/#purging","text":"For any lists of things (VLAN interfaces, bonds) the purge option can be enabled: \"/interface/vlan?name=vlan6\": { \"vlan-id\": \"6\", \"interface\": \"bridge\", \"needs\": { \"routeros:/interface/bridge?name=bridge\", }, }, \"/interface/vlan\": { \"purge\": { \"id-by\": \"name\", }, }, The id-by option tells BundleWrap to identify configured items by the specified key. In the above example, BundleWrap searches for all items with item ids starting wih /interface/vlan that contain a name key. It finds /interface/vlan?name=vlan6 and assumes that only one VLAN should be configured and it should have a name of vlan6 . It will then delete any VLANs on the node not matching this selection. For different items, different selection keys are useful. For example for bridge ports, the interface key is often used: \"/interface/bridge/port?interface=ether8\": { \"bridge\": \"bridge\", \"needs\": { \"routeros:/interface/bridge?name=bridge\", }, }, \"/interface/bridge/port\": { \"purge\": { \"id-by\": \"interface\", }, }, Again, the managed items under the /interface/bridge/port path are identified by the interface key and this key is also used to select items to be purged. For some types of items, not all subitems can be deleted. For example /interface/bridge/vlan will also list dynamic VLANs which are not configured and can thus not be removed. They automatically appear/disappear with the bridge ports using them. In these cases, additional attributes can be specified in the keep option. Any item on the node that has any attribute matching the keep filter will also be retained and not purged. \"/interface/bridge/vlan\": { \"purge\": { \"id-by\": \"vlan-ids\", \"keep\": { \"dynamic\": True, }, }, },","title":"Purging"},{"location":"items/routeros/#attribute-reference","text":"See also: The list of generic builtin item attributes BundleWrap will accept any attributes for these items and pass them through to the RouterOS API. All attribute values can be passed as strings. If given as integers or booleans, BundleWrap will convert them to strings for you. If given a set, list, or tuple of strings, BundleWrap will join those strings with commas. Since comment is an internal attribute for BundleWrap, use _comment to apply the comment attribute on a RouterOS item.","title":"Attribute reference"},{"location":"items/routeros/#delete","text":"When set to True , this item will be removed from the system. When using delete , no other attributes are allowed.","title":"delete"},{"location":"items/svc_freebsd/","text":"FreeBSD service items Handles services on FreeBSD. svc_freebsd = { \"bgpd\": { \"enabled\": True, # default \"running\": True, # default }, \"supervisord\": { \"running\": False, }, } Attribute reference See also: The list of generic builtin item attributes enabled True if the service shall be automatically started during system bootup; False otherwise. True , the default value, is needed on FreeBSD, as starting disabled services fails. running True if the service is expected to be running on the system; False if it should be stopped. Canned actions See also: Explanation of how canned actions work restart Restarts the service. stop Stops the service. stopstart Stops and starts the service.","title":"svc_freebsd"},{"location":"items/svc_freebsd/#freebsd-service-items","text":"Handles services on FreeBSD. svc_freebsd = { \"bgpd\": { \"enabled\": True, # default \"running\": True, # default }, \"supervisord\": { \"running\": False, }, }","title":"FreeBSD service items"},{"location":"items/svc_freebsd/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/svc_freebsd/#enabled","text":"True if the service shall be automatically started during system bootup; False otherwise. True , the default value, is needed on FreeBSD, as starting disabled services fails.","title":"enabled"},{"location":"items/svc_freebsd/#running","text":"True if the service is expected to be running on the system; False if it should be stopped.","title":"running"},{"location":"items/svc_freebsd/#canned-actions","text":"See also: Explanation of how canned actions work","title":"Canned actions"},{"location":"items/svc_freebsd/#restart","text":"Restarts the service.","title":"restart"},{"location":"items/svc_freebsd/#stop","text":"Stops the service.","title":"stop"},{"location":"items/svc_freebsd/#stopstart","text":"Stops and starts the service.","title":"stopstart"},{"location":"items/svc_openbsd/","text":"OpenBSD service items Handles services on OpenBSD. svc_openbsd = { \"bgpd\": { \"enabled\": True, # default \"running\": True, # default }, \"supervisord\": { \"running\": False, }, } Attribute reference See also: The list of generic builtin item attributes enabled True if the service shall be automatically started during system bootup; False otherwise. True , the default value, is needed on OpenBSD, as starting disabled services fails. running True if the service is expected to be running on the system; False if it should be stopped. Canned actions See also: Explanation of how canned actions work restart Restarts the service. stop Stops the service. stopstart Stops and starts the service.","title":"svc_openbsd"},{"location":"items/svc_openbsd/#openbsd-service-items","text":"Handles services on OpenBSD. svc_openbsd = { \"bgpd\": { \"enabled\": True, # default \"running\": True, # default }, \"supervisord\": { \"running\": False, }, }","title":"OpenBSD service items"},{"location":"items/svc_openbsd/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/svc_openbsd/#enabled","text":"True if the service shall be automatically started during system bootup; False otherwise. True , the default value, is needed on OpenBSD, as starting disabled services fails.","title":"enabled"},{"location":"items/svc_openbsd/#running","text":"True if the service is expected to be running on the system; False if it should be stopped.","title":"running"},{"location":"items/svc_openbsd/#canned-actions","text":"See also: Explanation of how canned actions work","title":"Canned actions"},{"location":"items/svc_openbsd/#restart","text":"Restarts the service.","title":"restart"},{"location":"items/svc_openbsd/#stop","text":"Stops the service.","title":"stop"},{"location":"items/svc_openbsd/#stopstart","text":"Stops and starts the service.","title":"stopstart"},{"location":"items/svc_openrc/","text":"openrc service items Handles services managed by openrc. svc_openrc = { \"sshd\": { \"enabled\": True, # default \"running\": True, # default \"runlevel\": \"default\", # default }, \"nginx\": { \"enabled\": False, \"running\": False, \"runlevel\": \"boot\", }, } Attribute reference See also: The list of generic builtin item attributes enabled True if the service shall be automatically started during system bootup; False otherwise. None makes BundleWrap ignore this setting. running True if the service is expected to be running on the system; False if it should be stopped. None makes BundleWrap ignore this setting. runlevel Name of the runlevel this service exists in. Defaults to \"default\" . Canned actions See also: Explanation of how canned actions work reload Reloads the service. Not all services support reloading. restart Restarts the service. stop Stops the service.","title":"svc_openrc"},{"location":"items/svc_openrc/#openrc-service-items","text":"Handles services managed by openrc. svc_openrc = { \"sshd\": { \"enabled\": True, # default \"running\": True, # default \"runlevel\": \"default\", # default }, \"nginx\": { \"enabled\": False, \"running\": False, \"runlevel\": \"boot\", }, }","title":"openrc service items"},{"location":"items/svc_openrc/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/svc_openrc/#enabled","text":"True if the service shall be automatically started during system bootup; False otherwise. None makes BundleWrap ignore this setting.","title":"enabled"},{"location":"items/svc_openrc/#running","text":"True if the service is expected to be running on the system; False if it should be stopped. None makes BundleWrap ignore this setting.","title":"running"},{"location":"items/svc_openrc/#runlevel","text":"Name of the runlevel this service exists in. Defaults to \"default\" .","title":"runlevel"},{"location":"items/svc_openrc/#canned-actions","text":"See also: Explanation of how canned actions work","title":"Canned actions"},{"location":"items/svc_openrc/#reload","text":"Reloads the service. Not all services support reloading.","title":"reload"},{"location":"items/svc_openrc/#restart","text":"Restarts the service.","title":"restart"},{"location":"items/svc_openrc/#stop","text":"Stops the service.","title":"stop"},{"location":"items/svc_systemd/","text":"systemd service items Handles services managed by systemd. svc_systemd = { \"fcron.service\": { \"enabled\": True, # default \"running\": True, # default \"masked\": False, # default }, \"sgopherd.socket\": { \"running\": False, }, } Attribute reference See also: The list of generic builtin item attributes enabled True if the service shall be automatically started during system bootup; False otherwise. None makes BundleWrap ignore this setting. running True if the service is expected to be running on the system; False if it should be stopped. None makes BundleWrap ignore this setting. masked True if the service is expected to be masked; False if it should be unmasked. None makes BundleWrap ignore this setting. Canned actions See also: Explanation of how canned actions work reload Reloads the service. restart Restarts the service. stop Stops the service.","title":"svc_systemd"},{"location":"items/svc_systemd/#systemd-service-items","text":"Handles services managed by systemd. svc_systemd = { \"fcron.service\": { \"enabled\": True, # default \"running\": True, # default \"masked\": False, # default }, \"sgopherd.socket\": { \"running\": False, }, }","title":"systemd service items"},{"location":"items/svc_systemd/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/svc_systemd/#enabled","text":"True if the service shall be automatically started during system bootup; False otherwise. None makes BundleWrap ignore this setting.","title":"enabled"},{"location":"items/svc_systemd/#running","text":"True if the service is expected to be running on the system; False if it should be stopped. None makes BundleWrap ignore this setting.","title":"running"},{"location":"items/svc_systemd/#masked","text":"True if the service is expected to be masked; False if it should be unmasked. None makes BundleWrap ignore this setting.","title":"masked"},{"location":"items/svc_systemd/#canned-actions","text":"See also: Explanation of how canned actions work","title":"Canned actions"},{"location":"items/svc_systemd/#reload","text":"Reloads the service.","title":"reload"},{"location":"items/svc_systemd/#restart","text":"Restarts the service.","title":"restart"},{"location":"items/svc_systemd/#stop","text":"Stops the service.","title":"stop"},{"location":"items/svc_systemv/","text":"System V service items Handles services managed by traditional System V init scripts. svc_systemv = { \"apache2\": { \"running\": True, # default }, \"mysql\": { \"running\": False, }, } Attribute reference See also: The list of generic builtin item attributes running True if the service is expected to be running on the system; False if it should be stopped. Canned actions See also: Explanation of how canned actions work reload Reloads the service. restart Restarts the service. stop Stops the service.","title":"svc_systemv"},{"location":"items/svc_systemv/#system-v-service-items","text":"Handles services managed by traditional System V init scripts. svc_systemv = { \"apache2\": { \"running\": True, # default }, \"mysql\": { \"running\": False, }, }","title":"System V service items"},{"location":"items/svc_systemv/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/svc_systemv/#running","text":"True if the service is expected to be running on the system; False if it should be stopped.","title":"running"},{"location":"items/svc_systemv/#canned-actions","text":"See also: Explanation of how canned actions work","title":"Canned actions"},{"location":"items/svc_systemv/#reload","text":"Reloads the service.","title":"reload"},{"location":"items/svc_systemv/#restart","text":"Restarts the service.","title":"restart"},{"location":"items/svc_systemv/#stop","text":"Stops the service.","title":"stop"},{"location":"items/svc_upstart/","text":"Upstart service items Handles services managed by Upstart. svc_upstart = { \"gunicorn\": { \"running\": True, # default }, \"celery\": { \"running\": False, }, } Attribute reference See also: The list of generic builtin item attributes running True if the service is expected to be running on the system; False if it should be stopped. Canned actions See also: Explanation of how canned actions work reload Reloads the service. restart Restarts the service. stop Stops the service. stopstart Stops and then starts the service. This is different from restart in that Upstart will pick up changes to the /etc/init/SERVICENAME.conf file, while restart will continue to use the version of that file that the service was originally started with. See http://askubuntu.com/a/238069 .","title":"svc_upstart"},{"location":"items/svc_upstart/#upstart-service-items","text":"Handles services managed by Upstart. svc_upstart = { \"gunicorn\": { \"running\": True, # default }, \"celery\": { \"running\": False, }, }","title":"Upstart service items"},{"location":"items/svc_upstart/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/svc_upstart/#running","text":"True if the service is expected to be running on the system; False if it should be stopped.","title":"running"},{"location":"items/svc_upstart/#canned-actions","text":"See also: Explanation of how canned actions work","title":"Canned actions"},{"location":"items/svc_upstart/#reload","text":"Reloads the service.","title":"reload"},{"location":"items/svc_upstart/#restart","text":"Restarts the service.","title":"restart"},{"location":"items/svc_upstart/#stop","text":"Stops the service.","title":"stop"},{"location":"items/svc_upstart/#stopstart","text":"Stops and then starts the service. This is different from restart in that Upstart will pick up changes to the /etc/init/SERVICENAME.conf file, while restart will continue to use the version of that file that the service was originally started with. See http://askubuntu.com/a/238069 .","title":"stopstart"},{"location":"items/symlink/","text":"Symlink items symlinks = { \"/some/symlink\": { \"group\": \"root\", \"owner\": \"root\", \"target\": \"/target/file\", }, } Attribute reference See also: The list of generic builtin item attributes target File or directory this symlink points to. This attribute is required. group Name of the group this symlink belongs to. Defaults to 'root' . Set to None if you don't want BundleWrap to change whatever is set on the node. owner Username of the symlink's owner. Defaults to 'root' . Set to None if you don't want BundleWrap to change whatever is set on the node.","title":"symlink"},{"location":"items/symlink/#symlink-items","text":"symlinks = { \"/some/symlink\": { \"group\": \"root\", \"owner\": \"root\", \"target\": \"/target/file\", }, }","title":"Symlink items"},{"location":"items/symlink/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/symlink/#target","text":"File or directory this symlink points to. This attribute is required.","title":"target"},{"location":"items/symlink/#group","text":"Name of the group this symlink belongs to. Defaults to 'root' . Set to None if you don't want BundleWrap to change whatever is set on the node.","title":"group"},{"location":"items/symlink/#owner","text":"Username of the symlink's owner. Defaults to 'root' . Set to None if you don't want BundleWrap to change whatever is set on the node.","title":"owner"},{"location":"items/user/","text":"User items Manages system user accounts. users = { \"jdoe\": { \"full_name\": \"Jane Doe\", \"gid\": 2342, \"groups\": [\"admins\", \"users\", \"wheel\"], \"home\": \"/home/jdoe\", \"password_hash\": \"$6$abcdef$ghijklmnopqrstuvwxyz\", \"shell\": \"/bin/zsh\", \"uid\": 4747, }, } Attribute reference See also: The list of generic builtin item attributes All attributes are optional. delete When set to True , this user will be removed from the system. Note that because of how userdel works, the primary group of the user will be removed if it contains no other users. When using delete , no other attributes are allowed. full_name Full name of the user. gid Primary group of the user as numerical ID or group name. Due to how useradd works, this attribute is required whenever you don't want the default behavior of useradd (usually that means automatically creating a group with the same name as the user). If you want to use an unmanaged group already on the node, you need this attribute. If you want to use a group managed by BundleWrap, you need this attribute. This is true even if the groups mentioned are in fact named like the user. groups List of groups (names, not GIDs) the user should belong to. Must NOT include the group referenced by gid . hash_method One of: md5 sha256 sha512 Defaults to sha512 . home Path to home directory. Defaults to /home/USERNAME . password The user's password in plaintext. Please do not write any passwords into your bundles. This attribute is intended to be used with an external source of passwords and filled dynamically. If you don't have or want such an elaborate setup, specify passwords using the password_hash attribute instead. If you don't specify a salt along with the password, BundleWrap will use a static salt. Be aware that this is basically the same as using no salt at all. password_hash Hashed password as it would be returned by crypt() and written to /etc/shadow . salt Recommended for use with the password attribute. BundleWrap will use 5000 rounds of SHA-512 on this salt and the provided password. shell Path to login shell executable. uid Numerical user ID. It's your job to make sure it's unique.","title":"user"},{"location":"items/user/#user-items","text":"Manages system user accounts. users = { \"jdoe\": { \"full_name\": \"Jane Doe\", \"gid\": 2342, \"groups\": [\"admins\", \"users\", \"wheel\"], \"home\": \"/home/jdoe\", \"password_hash\": \"$6$abcdef$ghijklmnopqrstuvwxyz\", \"shell\": \"/bin/zsh\", \"uid\": 4747, }, }","title":"User items"},{"location":"items/user/#attribute-reference","text":"See also: The list of generic builtin item attributes All attributes are optional.","title":"Attribute reference"},{"location":"items/user/#delete","text":"When set to True , this user will be removed from the system. Note that because of how userdel works, the primary group of the user will be removed if it contains no other users. When using delete , no other attributes are allowed.","title":"delete"},{"location":"items/user/#full_name","text":"Full name of the user.","title":"full_name"},{"location":"items/user/#gid","text":"Primary group of the user as numerical ID or group name. Due to how useradd works, this attribute is required whenever you don't want the default behavior of useradd (usually that means automatically creating a group with the same name as the user). If you want to use an unmanaged group already on the node, you need this attribute. If you want to use a group managed by BundleWrap, you need this attribute. This is true even if the groups mentioned are in fact named like the user.","title":"gid"},{"location":"items/user/#groups","text":"List of groups (names, not GIDs) the user should belong to. Must NOT include the group referenced by gid .","title":"groups"},{"location":"items/user/#hash_method","text":"One of: md5 sha256 sha512 Defaults to sha512 .","title":"hash_method"},{"location":"items/user/#home","text":"Path to home directory. Defaults to /home/USERNAME .","title":"home"},{"location":"items/user/#password","text":"The user's password in plaintext. Please do not write any passwords into your bundles. This attribute is intended to be used with an external source of passwords and filled dynamically. If you don't have or want such an elaborate setup, specify passwords using the password_hash attribute instead. If you don't specify a salt along with the password, BundleWrap will use a static salt. Be aware that this is basically the same as using no salt at all.","title":"password"},{"location":"items/user/#password_hash","text":"Hashed password as it would be returned by crypt() and written to /etc/shadow .","title":"password_hash"},{"location":"items/user/#salt","text":"Recommended for use with the password attribute. BundleWrap will use 5000 rounds of SHA-512 on this salt and the provided password.","title":"salt"},{"location":"items/user/#shell","text":"Path to login shell executable.","title":"shell"},{"location":"items/user/#uid","text":"Numerical user ID. It's your job to make sure it's unique.","title":"uid"},{"location":"items/zfs_dataset/","text":"ZFS datasets Manages ZFS datasets. zfs_datasets = { \"tank/mydataset\": { \"acltype\": \"posixacl\", \"atime\": \"on\", \"relatime\": \"on\", \"compression\": \"on\", \"dedup\": \"off\", \"mountpoint\": \"/mnt/mydataset\", \"readonly\": \"off\", \"quota\": \"1G\", \"recordsize\": \"131072\", \"logbias\": \"throughput\", }, } Attribute reference See also: The list of generic builtin item attributes mountpoint Controls where the dataset should be mounted. If you set this to None , bundlewrap will also automatically unmount the dataset for you. The dataset will get mounted if you specify a mountpoint. Any other attribute Sets the corresponding dataset properties. Make sure the property is available in our pool.","title":"zfs_dataset"},{"location":"items/zfs_dataset/#zfs-datasets","text":"Manages ZFS datasets. zfs_datasets = { \"tank/mydataset\": { \"acltype\": \"posixacl\", \"atime\": \"on\", \"relatime\": \"on\", \"compression\": \"on\", \"dedup\": \"off\", \"mountpoint\": \"/mnt/mydataset\", \"readonly\": \"off\", \"quota\": \"1G\", \"recordsize\": \"131072\", \"logbias\": \"throughput\", }, }","title":"ZFS datasets"},{"location":"items/zfs_dataset/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/zfs_dataset/#mountpoint","text":"Controls where the dataset should be mounted. If you set this to None , bundlewrap will also automatically unmount the dataset for you. The dataset will get mounted if you specify a mountpoint.","title":"mountpoint"},{"location":"items/zfs_dataset/#any-other-attribute","text":"Sets the corresponding dataset properties. Make sure the property is available in our pool.","title":"Any other attribute"},{"location":"items/zfs_pool/","text":"ZFS pools Manages ZFS pools. zfs_pools = { \"tank\": { \"when_creating\": { \"config\": [ { \"type\": \"mirror\", \"devices\": { \"/dev/sda\", \"/dev/sdb\", }, }, ], \"ashift\": 12, }, \"autoexpand\": False, \"autoreplace\": False, \"autotrim\": True, }, } Attribute reference See also: The list of generic builtin item attributes config A list of dicts. This allows you to create arbitrary pool configurations. Each dict must include a devices key, which must contain atleast one device to use. type is optional, if set, it must be one of these types: mirror - creates a mirrored vdev (like RAID1) raidz - creates a raidz vdev (like RAID5) raidz2 - creates a raidz2 vdev (like RAID6) raidz3 - creates a raidz3 vdev log - creates a ZIL vdev cache - creates a L2ARC vdev When creating a log vdev, you may only use one or two devices. BundleWrap will automatically create a log mirror if you specify two devices for your log vdev. ashift Sets the ashift attribute for a to-be-created pool. ashift gets ignored if the requested pool already exists. autoexpand, autoreplace, and autotrim Sets the corresponding zpool options autoexpand , autoreplace and autotrim .","title":"zfs_pool"},{"location":"items/zfs_pool/#zfs-pools","text":"Manages ZFS pools. zfs_pools = { \"tank\": { \"when_creating\": { \"config\": [ { \"type\": \"mirror\", \"devices\": { \"/dev/sda\", \"/dev/sdb\", }, }, ], \"ashift\": 12, }, \"autoexpand\": False, \"autoreplace\": False, \"autotrim\": True, }, }","title":"ZFS pools"},{"location":"items/zfs_pool/#attribute-reference","text":"See also: The list of generic builtin item attributes","title":"Attribute reference"},{"location":"items/zfs_pool/#config","text":"A list of dicts. This allows you to create arbitrary pool configurations. Each dict must include a devices key, which must contain atleast one device to use. type is optional, if set, it must be one of these types: mirror - creates a mirrored vdev (like RAID1) raidz - creates a raidz vdev (like RAID5) raidz2 - creates a raidz2 vdev (like RAID6) raidz3 - creates a raidz3 vdev log - creates a ZIL vdev cache - creates a L2ARC vdev When creating a log vdev, you may only use one or two devices. BundleWrap will automatically create a log mirror if you specify two devices for your log vdev.","title":"config"},{"location":"items/zfs_pool/#ashift","text":"Sets the ashift attribute for a to-be-created pool. ashift gets ignored if the requested pool already exists.","title":"ashift"},{"location":"items/zfs_pool/#autoexpand-autoreplace-and-autotrim","text":"Sets the corresponding zpool options autoexpand , autoreplace and autotrim .","title":"autoexpand, autoreplace, and autotrim"},{"location":"misc/about/","text":".bs-sidebar { display: none; } About Development on BundleWrap started in July 2012, borrowing some ideas from Bcfg2 . Some key features that are meant to set BundleWrap apart from other config management systems are: decentralized architecture pythonic and easily extendable easy to get started with true item-level parallelism (in addition to working on multiple nodes simultaneously, BundleWrap will continue to fix config files while installing a package on the same node) very customizable item dependencies collaboration features like node locking (to prevent simultaneous applies to the same node) and hooks for chat notifications built-in testing facility ( bw test ) can be used as a library BundleWrap is a \"pure\" free software project licensed under the terms of the GPLv3 , with no Enterprise Edition or commercial support.","title":"About"},{"location":"misc/about/#about","text":"Development on BundleWrap started in July 2012, borrowing some ideas from Bcfg2 . Some key features that are meant to set BundleWrap apart from other config management systems are: decentralized architecture pythonic and easily extendable easy to get started with true item-level parallelism (in addition to working on multiple nodes simultaneously, BundleWrap will continue to fix config files while installing a package on the same node) very customizable item dependencies collaboration features like node locking (to prevent simultaneous applies to the same node) and hooks for chat notifications built-in testing facility ( bw test ) can be used as a library BundleWrap is a \"pure\" free software project licensed under the terms of the GPLv3 , with no Enterprise Edition or commercial support.","title":"About"},{"location":"misc/contributing/","text":"Contributing We welcome all input and contributions to BundleWrap. If you've never done this sort of thing before, maybe check out contribution-guide.org . But don't be afraid to make mistakes, nobody expects your first contribution to be perfect. We'll gladly help you out. Submitting bug reports Please use the GitHub issue tracker and take a few minutes to look for existing reports of the same problem (open or closed!). If you've found a security issue or are not at all sure, just contact trehn@bundlewrap.org . Contributing code Before working on new features, try reaching out to one of the core authors first. We are very concerned with keeping BundleWrap lean and not introducing bloat. Here are the steps: Write your code. Awesome! If you haven't already done so, please consider writing tests. Otherwise, someone else will have to do it for you. Same goes for documentation. Set up a virtualenv and run pip install -r requirements.txt . Make sure you can connect to your localhost via ssh without using a password and that you are able to run sudo . Run py.test tests/ . Review and sign the Copyright Assignment Agreement (CAA) by adding your name and email to the AUTHORS file. (This step can be skipped if your contribution is too small to be considered intellectual property, e.g. spelling fixes) Open a pull request on GitHub . Feel great. Thank you. Contributing documentation The process is essentially the same as detailed above for code contributions. You will find the docs in docs/content/ and can preview them using cd docs && mkdocs serve . Help If at any point you need help or are not sure what to do, open a discussion on GitHub . Release If you have been given the required access, to release a new version, do the following: Check out the current main branch Bump the version number in setup.py and bundlewrap/__init__.py , observing semantic versioning Add an entry to CHANGELOG.md , taking care to list all changes relevant to users and to order them with the most important changes on top (generally: new features, changes/improvements, bug fixes) Commit these changes into a new commit titled release X.Y.Z , replacing X.Y.Z with the new version Push to GitHub Wait for GitHub Actions to successfully build (use your best judgment for DeepSource failures, some are very acceptable; in case of other failures, rebase fixes below the release commit) Tag the release commit with the version number and push the tag Create a new release on GitHub referencing the tag, using the version number as the title and the content from the CHANGELOG.md entry as the description Run rm -rf build dist , just in case Run python -m build Run twine upload dist/* Run mkdocs gh-deploy in the docs/ directory Rejoice with glee!","title":"Contributing"},{"location":"misc/contributing/#contributing","text":"We welcome all input and contributions to BundleWrap. If you've never done this sort of thing before, maybe check out contribution-guide.org . But don't be afraid to make mistakes, nobody expects your first contribution to be perfect. We'll gladly help you out.","title":"Contributing"},{"location":"misc/contributing/#submitting-bug-reports","text":"Please use the GitHub issue tracker and take a few minutes to look for existing reports of the same problem (open or closed!). If you've found a security issue or are not at all sure, just contact trehn@bundlewrap.org .","title":"Submitting bug reports"},{"location":"misc/contributing/#contributing-code","text":"Before working on new features, try reaching out to one of the core authors first. We are very concerned with keeping BundleWrap lean and not introducing bloat. Here are the steps: Write your code. Awesome! If you haven't already done so, please consider writing tests. Otherwise, someone else will have to do it for you. Same goes for documentation. Set up a virtualenv and run pip install -r requirements.txt . Make sure you can connect to your localhost via ssh without using a password and that you are able to run sudo . Run py.test tests/ . Review and sign the Copyright Assignment Agreement (CAA) by adding your name and email to the AUTHORS file. (This step can be skipped if your contribution is too small to be considered intellectual property, e.g. spelling fixes) Open a pull request on GitHub . Feel great. Thank you.","title":"Contributing code"},{"location":"misc/contributing/#contributing-documentation","text":"The process is essentially the same as detailed above for code contributions. You will find the docs in docs/content/ and can preview them using cd docs && mkdocs serve .","title":"Contributing documentation"},{"location":"misc/contributing/#help","text":"If at any point you need help or are not sure what to do, open a discussion on GitHub .","title":"Help"},{"location":"misc/contributing/#release","text":"If you have been given the required access, to release a new version, do the following: Check out the current main branch Bump the version number in setup.py and bundlewrap/__init__.py , observing semantic versioning Add an entry to CHANGELOG.md , taking care to list all changes relevant to users and to order them with the most important changes on top (generally: new features, changes/improvements, bug fixes) Commit these changes into a new commit titled release X.Y.Z , replacing X.Y.Z with the new version Push to GitHub Wait for GitHub Actions to successfully build (use your best judgment for DeepSource failures, some are very acceptable; in case of other failures, rebase fixes below the release commit) Tag the release commit with the version number and push the tag Create a new release on GitHub referencing the tag, using the version number as the title and the content from the CHANGELOG.md entry as the description Run rm -rf build dist , just in case Run python -m build Run twine upload dist/* Run mkdocs gh-deploy in the docs/ directory Rejoice with glee!","title":"Release"},{"location":"misc/deciding/","text":".bs-sidebar { display: none; } Is BundleWrap the right tool for you? We think you will enjoy BundleWrap a lot if you: know some Python like to write your configuration from scratch and control every bit of it have lots of unique nodes are trying to get a lot of existing systems under management are NOT trying to handle a massive amount of nodes (let\u2019s say more than 1000) like to start small don\u2019t want yet more stuff to run on your nodes (or mess with appliances as little as possible) prefer a simple tool to a fancy one want as much as possible in git/hg/bzr have strongly segmented internal networks You might be better served with a different config management system if you: are already using a config management system and don\u2019t have any major issues hate Python and/or JSON like to use community-maintained configuration templates need unattended bootstrapping of nodes don\u2019t trust your coworkers","title":"Why BundleWrap"},{"location":"misc/deciding/#is-bundlewrap-the-right-tool-for-you","text":"We think you will enjoy BundleWrap a lot if you: know some Python like to write your configuration from scratch and control every bit of it have lots of unique nodes are trying to get a lot of existing systems under management are NOT trying to handle a massive amount of nodes (let\u2019s say more than 1000) like to start small don\u2019t want yet more stuff to run on your nodes (or mess with appliances as little as possible) prefer a simple tool to a fancy one want as much as possible in git/hg/bzr have strongly segmented internal networks You might be better served with a different config management system if you: are already using a config management system and don\u2019t have any major issues hate Python and/or JSON like to use community-maintained configuration templates need unattended bootstrapping of nodes don\u2019t trust your coworkers","title":"Is BundleWrap the right tool for you?"},{"location":"misc/faq/","text":"FAQ Technical BundleWrap says an item failed to apply, what do I do now? Try running bw apply -i nodename to see which attribute of the item could not be fixed. If that doesn't tell you enough, try bw --debug apply -i nodename and look for the command BundleWrap is using to fix the item in question. Then try running that command yourself and check for any errors. What happens when two people start applying configuration to the same node? BundleWrap uses a locking mechanism to prevent collisions like this. How can I have BundleWrap reload my services after config changes? See canned actions and triggers . Will BundleWrap keep track of package updates? No. BundleWrap will only care about whether a package is installed or not. Updates will have to be installed through a separate mechanism (I like to create an action with the interactive attribute set to True ). Selecting specific versions should be done through your package manager. Is there a probing mechanism like Ohai? No. BundleWrap is meant to be very push-focused. The node should not have any say in what configuration it will receive. Is BundleWrap secure? BundleWrap is more concerned with safety than security. Due to its design, it is possible for your coworkers to introduce malicious code into a BundleWrap repository that could compromise your machine. You should only use trusted repositories and code. We also recommend following commit logs to your repos. The BundleWrap Project Why doesn't BundleWrap provide pre-built community bundles? In our experience, bundles for even the most common pieces of software always contain some opinionated bits specific to local infrastructure. Making bundles truly universal (e.g. in terms of supported Linux distributions) would mean a lot of bloat. And since local modifications are hard to reconcile with an upstream community repository, bundles would have to be very feature-complete to be useful to the majority of users, increasing bloat even more. Maintaining bundles and thus configuration for different pieces of software is therefore out of scope for the BundleWrap project. While it might seem tedious when you're getting started, with some practice, writing your own bundles will become both easy and precise in terms of infrastructure fit. Why do contributors have to sign a Copyright Assignment Agreement? While it sounds scary, Copyright assignment is used to improve the enforceability of the GPL. Even the FSF does it, read their explanation why . The agreement used by BundleWrap is from harmonyagreements.org . If you're still concerned, please do not hesitate to contact @trehn .","title":"FAQ"},{"location":"misc/faq/#faq","text":"","title":"FAQ"},{"location":"misc/faq/#technical","text":"","title":"Technical"},{"location":"misc/faq/#bundlewrap-says-an-item-failed-to-apply-what-do-i-do-now","text":"Try running bw apply -i nodename to see which attribute of the item could not be fixed. If that doesn't tell you enough, try bw --debug apply -i nodename and look for the command BundleWrap is using to fix the item in question. Then try running that command yourself and check for any errors.","title":"BundleWrap says an item failed to apply, what do I do now?"},{"location":"misc/faq/#what-happens-when-two-people-start-applying-configuration-to-the-same-node","text":"BundleWrap uses a locking mechanism to prevent collisions like this.","title":"What happens when two people start applying configuration to the same node?"},{"location":"misc/faq/#how-can-i-have-bundlewrap-reload-my-services-after-config-changes","text":"See canned actions and triggers .","title":"How can I have BundleWrap reload my services after config changes?"},{"location":"misc/faq/#will-bundlewrap-keep-track-of-package-updates","text":"No. BundleWrap will only care about whether a package is installed or not. Updates will have to be installed through a separate mechanism (I like to create an action with the interactive attribute set to True ). Selecting specific versions should be done through your package manager.","title":"Will BundleWrap keep track of package updates?"},{"location":"misc/faq/#is-there-a-probing-mechanism-like-ohai","text":"No. BundleWrap is meant to be very push-focused. The node should not have any say in what configuration it will receive.","title":"Is there a probing mechanism like Ohai?"},{"location":"misc/faq/#is-bundlewrap-secure","text":"BundleWrap is more concerned with safety than security. Due to its design, it is possible for your coworkers to introduce malicious code into a BundleWrap repository that could compromise your machine. You should only use trusted repositories and code. We also recommend following commit logs to your repos.","title":"Is BundleWrap secure?"},{"location":"misc/faq/#the-bundlewrap-project","text":"","title":"The BundleWrap Project"},{"location":"misc/faq/#why-doesnt-bundlewrap-provide-pre-built-community-bundles","text":"In our experience, bundles for even the most common pieces of software always contain some opinionated bits specific to local infrastructure. Making bundles truly universal (e.g. in terms of supported Linux distributions) would mean a lot of bloat. And since local modifications are hard to reconcile with an upstream community repository, bundles would have to be very feature-complete to be useful to the majority of users, increasing bloat even more. Maintaining bundles and thus configuration for different pieces of software is therefore out of scope for the BundleWrap project. While it might seem tedious when you're getting started, with some practice, writing your own bundles will become both easy and precise in terms of infrastructure fit.","title":"Why doesn't BundleWrap provide pre-built community bundles?"},{"location":"misc/faq/#why-do-contributors-have-to-sign-a-copyright-assignment-agreement","text":"While it sounds scary, Copyright assignment is used to improve the enforceability of the GPL. Even the FSF does it, read their explanation why . The agreement used by BundleWrap is from harmonyagreements.org . If you're still concerned, please do not hesitate to contact @trehn .","title":"Why do contributors have to sign a Copyright Assignment Agreement?"},{"location":"misc/glossary/","text":"Glossary action Actions are a special kind of item used for running shell commands during each bw apply . They allow you to do things that aren't persistent in nature. apply An \"apply\" is what we call the process of what's otherwise known as \"converging\" the state described by your repository and the actual status quo on the node. bundle A collection of items. Most of the time, you will create one bundle per application. For example, an Apache bundle will include the httpd service, the virtual host definitions and the apache2 package. group Used for organizing your nodes. hook Hooks can be used to run your own code automatically during various stages of BundleWrap operations. item A single piece of configuration on a node, e.g. a file or an installed package. You might be interested in this overview of item types . lib Libs are a way to store Python modules in your repository and make them accessible to your bundles and templates. node A managed system, no matter if physical or virtual. repo A repository is a directory with some stuff in it that tells BundleWrap everything it needs to know about your infrastructure.","title":"Glossary"},{"location":"misc/glossary/#glossary","text":"","title":"Glossary"},{"location":"misc/glossary/#action","text":"Actions are a special kind of item used for running shell commands during each bw apply . They allow you to do things that aren't persistent in nature.","title":"action"},{"location":"misc/glossary/#apply","text":"An \"apply\" is what we call the process of what's otherwise known as \"converging\" the state described by your repository and the actual status quo on the node.","title":"apply"},{"location":"misc/glossary/#bundle","text":"A collection of items. Most of the time, you will create one bundle per application. For example, an Apache bundle will include the httpd service, the virtual host definitions and the apache2 package.","title":"bundle"},{"location":"misc/glossary/#group","text":"Used for organizing your nodes.","title":"group"},{"location":"misc/glossary/#hook","text":"Hooks can be used to run your own code automatically during various stages of BundleWrap operations.","title":"hook"},{"location":"misc/glossary/#item","text":"A single piece of configuration on a node, e.g. a file or an installed package. You might be interested in this overview of item types .","title":"item"},{"location":"misc/glossary/#lib","text":"Libs are a way to store Python modules in your repository and make them accessible to your bundles and templates.","title":"lib"},{"location":"misc/glossary/#node","text":"A managed system, no matter if physical or virtual.","title":"node"},{"location":"misc/glossary/#repo","text":"A repository is a directory with some stuff in it that tells BundleWrap everything it needs to know about your infrastructure.","title":"repo"},{"location":"repo/bundle.py/","text":"bundle.py Within each bundle, there may be a file called bundle.py . It can be used to add dependencies and such to all items with a given tag (see items.py for a general introduction to these concepts). Here's an example: tags = { 'foo': { 'needs': { 'svc_systemd:bar', }, 'triggers': { 'action:baz', }, }, } With this, whenever you add the foo tag to an item in items.py , that item will also depend on svc_systemd:bar and trigger action:baz . Supported item attributes are: * needs * needed_by * precedes * preceded_by * tags * triggers * triggered_by See Selectors for a complete overview of the ways to specify items here.","title":"bundles/.../bundle.py"},{"location":"repo/groups.py/","text":"groups.py This file lets you specify or dynamically build groups of nodes in your environment. As with nodes.py , you define your groups as a dictionary: groups = { 'all': { 'member_patterns': ( r\".*\", ), }, 'group1': { 'members': ( 'node1', ), }, } All group attributes are optional. Group attribute reference This section is a reference for all possible attributes you can define for a group: groups = { 'group1': { # THIS PART IS EXPLAINED HERE 'bundles': [\"bundle1\", \"bundle2\"], 'members': [\"node1\"], 'member_patterns': [r\"^cluster1\\.\"], 'metadata': {'foo': \"bar\"}, 'os': 'linux', 'subgroups': [\"group2\", \"group3\"], 'subgroup_patterns': [r\"^group.*pattern$\"], }, } Note that many attributes from nodes.py (e.g. bundles ) may also be set at group level, but aren't explicitly documented here again. member_patterns A list of regular expressions. Node names matching these expressions will be added to the group members. Matches are determined using the search() method . members A tuple or list of node names that belong to this group. metadata A dictionary that will be accessible from each node's node.metadata . For each node, BundleWrap will merge the metadata of all of the node's groups first, then merge in the metadata from the node itself. Metadata is merged recursively by default, meaning nested dicts will overlay each other. Lists will be appended to each other, but not recursed into. In come cases, you want to overwrite instead of merge a piece of metadata. This is accomplished through the use of bundlewrap.metadata.atomic() and best illustrated as an example: from bundlewrap.metadata import atomic groups = { 'all': { 'metadata': { 'interfaces': { 'eth0': {}, }, 'nameservers': [\"8.8.8.8\", \"8.8.4.4\"], 'ntp_servers': [\"pool.ntp.org\"], }, }, 'internal': { 'metadata': 'interfaces': { 'eth1': {}, }, 'nameservers': atomic([\"10.0.0.1\", \"10.0.0.2\"]), 'ntp_servers': [\"10.0.0.1\", \"10.0.0.2\"], }, }, } A node in both groups will end up with eth0 and eth1 . The nameservers however are overwritten, so that nodes that are in both the \"all\" and the \"internal\" group will only have the 10.0.0.x ones while nodes just in the \"all\" group will have the 8.8.x.x nameservers. The NTP servers are appended: a node in both groups will have all three of them. BundleWrap will consider group hierarchy when merging metadata. For example, it is possible to define a default nameserver for the \"eu\" group and then override it for the \"eu.frankfurt\" subgroup. The catch is that this only works for groups that are connected through a subgroup hierarchy. Independent groups will have their metadata merged in an undefined order. bw test will report conflicting metadata in independent groups as a metadata collision. Also see the documentation for node.metadata and metadata.py for more information. subgroups A tuple or list of group names whose members should be recursively included in this group. subgroup_patterns A list of regular expressions. Nodes in with group names matching these expressions will be added to the group members. Matches are determined using the search() method . supergroups The inverse of subgroups . Nodes in this group will be added to all supergroups.","title":"groups.py"},{"location":"repo/groups.py/#groupspy","text":"This file lets you specify or dynamically build groups of nodes in your environment. As with nodes.py , you define your groups as a dictionary: groups = { 'all': { 'member_patterns': ( r\".*\", ), }, 'group1': { 'members': ( 'node1', ), }, } All group attributes are optional.","title":"groups.py"},{"location":"repo/groups.py/#group-attribute-reference","text":"This section is a reference for all possible attributes you can define for a group: groups = { 'group1': { # THIS PART IS EXPLAINED HERE 'bundles': [\"bundle1\", \"bundle2\"], 'members': [\"node1\"], 'member_patterns': [r\"^cluster1\\.\"], 'metadata': {'foo': \"bar\"}, 'os': 'linux', 'subgroups': [\"group2\", \"group3\"], 'subgroup_patterns': [r\"^group.*pattern$\"], }, } Note that many attributes from nodes.py (e.g. bundles ) may also be set at group level, but aren't explicitly documented here again.","title":"Group attribute reference"},{"location":"repo/groups.py/#member_patterns","text":"A list of regular expressions. Node names matching these expressions will be added to the group members. Matches are determined using the search() method .","title":"member_patterns"},{"location":"repo/groups.py/#members","text":"A tuple or list of node names that belong to this group.","title":"members"},{"location":"repo/groups.py/#metadata","text":"A dictionary that will be accessible from each node's node.metadata . For each node, BundleWrap will merge the metadata of all of the node's groups first, then merge in the metadata from the node itself. Metadata is merged recursively by default, meaning nested dicts will overlay each other. Lists will be appended to each other, but not recursed into. In come cases, you want to overwrite instead of merge a piece of metadata. This is accomplished through the use of bundlewrap.metadata.atomic() and best illustrated as an example: from bundlewrap.metadata import atomic groups = { 'all': { 'metadata': { 'interfaces': { 'eth0': {}, }, 'nameservers': [\"8.8.8.8\", \"8.8.4.4\"], 'ntp_servers': [\"pool.ntp.org\"], }, }, 'internal': { 'metadata': 'interfaces': { 'eth1': {}, }, 'nameservers': atomic([\"10.0.0.1\", \"10.0.0.2\"]), 'ntp_servers': [\"10.0.0.1\", \"10.0.0.2\"], }, }, } A node in both groups will end up with eth0 and eth1 . The nameservers however are overwritten, so that nodes that are in both the \"all\" and the \"internal\" group will only have the 10.0.0.x ones while nodes just in the \"all\" group will have the 8.8.x.x nameservers. The NTP servers are appended: a node in both groups will have all three of them. BundleWrap will consider group hierarchy when merging metadata. For example, it is possible to define a default nameserver for the \"eu\" group and then override it for the \"eu.frankfurt\" subgroup. The catch is that this only works for groups that are connected through a subgroup hierarchy. Independent groups will have their metadata merged in an undefined order. bw test will report conflicting metadata in independent groups as a metadata collision. Also see the documentation for node.metadata and metadata.py for more information.","title":"metadata"},{"location":"repo/groups.py/#subgroups","text":"A tuple or list of group names whose members should be recursively included in this group.","title":"subgroups"},{"location":"repo/groups.py/#subgroup_patterns","text":"A list of regular expressions. Nodes in with group names matching these expressions will be added to the group members. Matches are determined using the search() method .","title":"subgroup_patterns"},{"location":"repo/groups.py/#supergroups","text":"The inverse of subgroups . Nodes in this group will be added to all supergroups.","title":"supergroups"},{"location":"repo/hooks/","text":"Hooks Hooks enable you to execute custom code at certain points during a BundleWrap run. This is useful for integrating with other systems e.g. for team notifications, logging or statistics. To use hooks, you need to create a subdirectory in your repo called hooks . In that directory you can place an arbitrary number of Python source files. If those source files define certain functions, these functions will be called at the appropriate time. Example hooks/my_awesome_notification.py : from my_awesome_notification_system import post_message def node_apply_start(repo, node, interactive=False, **kwargs): post_message(\"Starting apply on {}, everything is gonna be OK!\".format(node.name)) Always define your hooks with **kwargs so we can pass in more information in future updates without breaking your hook. Functions This is a list of all functions a hook file may implement. action_run_start(repo, node, item, **kwargs) Called each time a bw apply command reaches a new action. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). item The current action. action_run_end(repo, node, item, duration=None, status=None, **kwargs) Called each time a bw apply command completes processing an action. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). item The current action. duration How long the action was running (timedelta). status : One of bundlewrap.items.Item.STATUS_FAILED , bundlewrap.items.Item.STATUS_SKIPPED , or bundlewrap.items.Item.STATUS_ACTION_SUCCEEDED . apply_start(repo, target, nodes, interactive=False, **kwargs) Called when you start a bw apply command. repo The current repository (instance of bundlewrap.repo.Repository ). target The group or node name you gave on the command line. nodes A list of node objects affected (list of bundlewrap.node.Node instances). interactive Indicates whether the apply is interactive or not. To abort the entire apply operation: from bundlewrap.exceptions import GracefulApplyException raise GracefulApplyException(\"reason goes here\") apply_end(repo, target, nodes, duration=None, **kwargs) Called when a bw apply command completes. repo The current repository (instance of bundlewrap.repo.Repository ). target The group or node name you gave on the command line. nodes A list of node objects affected (list of bundlewrap.node.Node instances). duration How long the apply took (timedelta). item_apply_start(repo, node, item, **kwargs) Called each time a bw apply command reaches a new item. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). item The current item. node_ssh_connect(repo, node, **kwargs) Called before the first ssh connection attempt is made once per node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). item_apply_end(repo, node, item, duration=None, status_code=None, status_before=None, status_after=None, **kwargs) Called each time a bw apply command completes processing an item. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). item The current item. duration How long the apply took (timedelta). status_code One of bundlewrap.items.Item.STATUS_FAILED , bundlewrap.items.Item.STATUS_SKIPPED , bundlewrap.items.Item.STATUS_OK , or bundlewrap.items.Item.STATUS_FIXED . status_before An instance of bundlewrap.items.ItemStatus . status_after See status_before . lock_add(repo, node, lock_id, items, expiry, comment, **kwargs) Called each time a soft lock is added to a node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). lock_id The random ID of the lock. items List of item selector strings. expiry UNIX timestamp of lock expiry time (int). comment As entered by user. lock_remove(repo, node, lock_id, **kwargs) Called each time a soft lock is removed from a node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). lock_id The random ID of the lock. lock_show(repo, node, lock_info, **kwargs) Called each time bw lock show finds a lock on a node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). lock_info A dict contain the lock details. node_apply_start(repo, node, interactive=False, **kwargs) Called each time a bw apply command reaches a new node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). interactive True if this is an interactive apply run. To skip a node: from bundlewrap.exceptions import SkipNode raise SkipNode(\"reason goes here\") node_apply_end(repo, node, duration=None, interactive=False, result=None, **kwargs) Called each time a bw apply command finishes processing a node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). duration How long the apply took (timedelta). interactive True if this was an interactive apply run. result An instance of bundlewrap.node.ApplyResult . node_run_start(repo, node, command, **kwargs) Called each time a bw run command reaches a new node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). command The command that will be run on the node. To skip a node: from bundlewrap.exceptions import SkipNode raise SkipNode(\"reason goes here\") node_run_end(repo, node, command, duration=None, return_code=None, stdout=\"\", stderr=\"\", **kwargs) Called each time a bw run command finishes on a node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). command The command that was run on the node. duration How long it took to run the command (timedelta). return_code Return code of the remote command. stdout The captured stdout stream of the remote command. stderr The captured stderr stream of the remote command. run_start(repo, target, nodes, command, **kwargs) Called each time a bw run command starts. repo The current repository (instance of bundlewrap.repo.Repository ). target The group or node name you gave on the command line. nodes A list of node objects affected (list of bundlewrap.node.Node instances). command The command that will be run on the node. run_end(repo, target, nodes, command, duration=None, **kwargs) Called each time a bw run command finishes. repo The current repository (instance of bundlewrap.repo.Repository ). target The group or node name you gave on the command line. nodes A list of node objects affected (list of bundlewrap.node.Node instances). command The command that was run. duration How long it took to run the command on all nodes (timedelta). test(repo, **kwargs) Called at the end of a full bw test . repo The current repository (instance of bundlewrap.repo.Repository ). test_node(repo, node, **kwargs) Called during bw test for each node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ).","title":"hooks/"},{"location":"repo/hooks/#hooks","text":"Hooks enable you to execute custom code at certain points during a BundleWrap run. This is useful for integrating with other systems e.g. for team notifications, logging or statistics. To use hooks, you need to create a subdirectory in your repo called hooks . In that directory you can place an arbitrary number of Python source files. If those source files define certain functions, these functions will be called at the appropriate time.","title":"Hooks"},{"location":"repo/hooks/#example","text":"hooks/my_awesome_notification.py : from my_awesome_notification_system import post_message def node_apply_start(repo, node, interactive=False, **kwargs): post_message(\"Starting apply on {}, everything is gonna be OK!\".format(node.name)) Always define your hooks with **kwargs so we can pass in more information in future updates without breaking your hook.","title":"Example"},{"location":"repo/hooks/#functions","text":"This is a list of all functions a hook file may implement. action_run_start(repo, node, item, **kwargs) Called each time a bw apply command reaches a new action. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). item The current action. action_run_end(repo, node, item, duration=None, status=None, **kwargs) Called each time a bw apply command completes processing an action. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). item The current action. duration How long the action was running (timedelta). status : One of bundlewrap.items.Item.STATUS_FAILED , bundlewrap.items.Item.STATUS_SKIPPED , or bundlewrap.items.Item.STATUS_ACTION_SUCCEEDED . apply_start(repo, target, nodes, interactive=False, **kwargs) Called when you start a bw apply command. repo The current repository (instance of bundlewrap.repo.Repository ). target The group or node name you gave on the command line. nodes A list of node objects affected (list of bundlewrap.node.Node instances). interactive Indicates whether the apply is interactive or not. To abort the entire apply operation: from bundlewrap.exceptions import GracefulApplyException raise GracefulApplyException(\"reason goes here\") apply_end(repo, target, nodes, duration=None, **kwargs) Called when a bw apply command completes. repo The current repository (instance of bundlewrap.repo.Repository ). target The group or node name you gave on the command line. nodes A list of node objects affected (list of bundlewrap.node.Node instances). duration How long the apply took (timedelta). item_apply_start(repo, node, item, **kwargs) Called each time a bw apply command reaches a new item. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). item The current item. node_ssh_connect(repo, node, **kwargs) Called before the first ssh connection attempt is made once per node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). item_apply_end(repo, node, item, duration=None, status_code=None, status_before=None, status_after=None, **kwargs) Called each time a bw apply command completes processing an item. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). item The current item. duration How long the apply took (timedelta). status_code One of bundlewrap.items.Item.STATUS_FAILED , bundlewrap.items.Item.STATUS_SKIPPED , bundlewrap.items.Item.STATUS_OK , or bundlewrap.items.Item.STATUS_FIXED . status_before An instance of bundlewrap.items.ItemStatus . status_after See status_before . lock_add(repo, node, lock_id, items, expiry, comment, **kwargs) Called each time a soft lock is added to a node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). lock_id The random ID of the lock. items List of item selector strings. expiry UNIX timestamp of lock expiry time (int). comment As entered by user. lock_remove(repo, node, lock_id, **kwargs) Called each time a soft lock is removed from a node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). lock_id The random ID of the lock. lock_show(repo, node, lock_info, **kwargs) Called each time bw lock show finds a lock on a node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). lock_info A dict contain the lock details. node_apply_start(repo, node, interactive=False, **kwargs) Called each time a bw apply command reaches a new node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). interactive True if this is an interactive apply run. To skip a node: from bundlewrap.exceptions import SkipNode raise SkipNode(\"reason goes here\") node_apply_end(repo, node, duration=None, interactive=False, result=None, **kwargs) Called each time a bw apply command finishes processing a node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). duration How long the apply took (timedelta). interactive True if this was an interactive apply run. result An instance of bundlewrap.node.ApplyResult . node_run_start(repo, node, command, **kwargs) Called each time a bw run command reaches a new node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). command The command that will be run on the node. To skip a node: from bundlewrap.exceptions import SkipNode raise SkipNode(\"reason goes here\") node_run_end(repo, node, command, duration=None, return_code=None, stdout=\"\", stderr=\"\", **kwargs) Called each time a bw run command finishes on a node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ). command The command that was run on the node. duration How long it took to run the command (timedelta). return_code Return code of the remote command. stdout The captured stdout stream of the remote command. stderr The captured stderr stream of the remote command. run_start(repo, target, nodes, command, **kwargs) Called each time a bw run command starts. repo The current repository (instance of bundlewrap.repo.Repository ). target The group or node name you gave on the command line. nodes A list of node objects affected (list of bundlewrap.node.Node instances). command The command that will be run on the node. run_end(repo, target, nodes, command, duration=None, **kwargs) Called each time a bw run command finishes. repo The current repository (instance of bundlewrap.repo.Repository ). target The group or node name you gave on the command line. nodes A list of node objects affected (list of bundlewrap.node.Node instances). command The command that was run. duration How long it took to run the command on all nodes (timedelta). test(repo, **kwargs) Called at the end of a full bw test . repo The current repository (instance of bundlewrap.repo.Repository ). test_node(repo, node, **kwargs) Called during bw test for each node. repo The current repository (instance of bundlewrap.repo.Repository ). node The current node (instance of bundlewrap.node.Node ).","title":"Functions"},{"location":"repo/items.py/","text":"items.py Within each bundle, there may be a file called items.py . It defines any number of magic attributes that are automatically processed by BundleWrap. Each attribute is a dictionary mapping an item name (such as a file name) to a dictionary of attributes (e.g. file ownership information). A typical items.py might look like this: files = { '/etc/hosts': { 'owner': \"root\", 'group': \"root\", 'mode': \"0664\", [...] }, } users = { 'janedoe': { 'home': \"/home/janedoe\", 'shell': \"/bin/zsh\", [...] }, 'johndoe': { 'home': \"/home/johndoe\", 'shell': \"/bin/bash\", [...] }, } This bundle defines the attributes files and users . Within the users attribute, there are two user items. Each item maps its name to a dictionary that is understood by the specific kind of item. Below you will find a reference of all builtin item types and the attributes they understand. You can also define your own item types . Item types This table lists all item types included in BundleWrap along with the bundle attributes they understand. Type Bundle attribute Description action actions Actions allow you to run commands on every bw apply directory directories Manages permissions and ownership for directories file files Manages contents, permissions, and ownership for files git_deploy git_deploy Deploys the contents of a git repository group groups Manages groups by wrapping groupadd , groupmod and groupdel k8s_* k8s_* Manages resources in Kubernetes clusters by wrapping kubectl pkg_apt pkg_apt Installs and removes packages with APT pkg_dnf pkg_dnf Installs and removes packages with dnf pkg_opkg pkg_opkg Installs and removes packages with opkg pkg_pacman pkg_pacman Installs and removes packages with pacman pkg_pamac pkg_pamac Installs and removes packages with pamac pkg_pip pkg_pip Installs and removes Python packages with pip pkg_snap pkg_snap Installs and removes packages with snap pkg_yum pkg_yum Installs and removes packages with yum pkg_zypper pkg_zypper Installs and removes packages with zypper postgres_db postgres_dbs Manages Postgres databases postgres_role postgres_roles Manages Postgres roles pkg_pip pkg_pip Installs and removes Python packages with pip pkg_freebsd pkg_freebsd Installs and removes FreeBSD packages with pkg pkg_openbsd pkg_openbsd Installs and removes OpenBSD packages with pkg_add/pkg_delete routeros routeros Manages RouterOS configuration svc_freebsd svc_freebsd Starts and stops services with FreeBSD's rc svc_openbsd svc_openbsd Starts and stops services with OpenBSD's rc svc_systemd svc_systemd Starts and stops services with systemd svc_systemv svc_systemv Starts and stops services with traditional System V init scripts svc_upstart svc_upstart Starts and stops services with Upstart symlink symlinks Manages symbolic links and their ownership user users Manages users by wrapping useradd , usermod and userdel zfs_dataset zfs_datasets Manages ZFS datasets zfs_pool zfs_pools Manages ZFS pools Builtin item attributes There are also attributes that can be applied to any kind of item. after This lets you control execution order of items. This is not something you will have to do very often, because there are already implicit dependencies between item types (e.g. all files automatically depend on the users owning them). actions = { 'a': { 'command': 'true', }, 'b': { 'command': 'true', 'after': {'action:a'}, }, } When set up like this, action:b will only run after action:a has been completed. Note that it doesn't matter if action:a is successful or not, that what needs is for. See Selectors for a complete overview of the ways to specify items here. before Just like after , but in the opposite direction. comment This is a string that will be displayed in interactive mode ( bw apply -i ) whenever the item is to be changed in any way. You can use it to warn users before they start disruptive actions. error_on_missing_fault This will simply skip an item instead of raising an error when a Fault used for an attribute on the item is unavailable. Faults are special objects used by repo.vault to handle secrets . A Fault being unavailable can mean you're missing the secret key required to decrypt a secret you're trying to use as an item attribute value. Defaults to False . needs This allows for setting up dependencies between items. Here are two examples: my_items = { 'item1': { [...] 'needs': [ 'file:/etc/foo.conf', ], }, 'item2': { [...] 'needs': [ 'pkg_apt:', 'bundle:foo', ], } } The first item ( item1 , specific attributes have been omitted) depends on a file called /etc/foo.conf , while item2 depends on all APT packages being installed and every item in the foo bundle. Note that unlike after , with needs the depending item will be skipped if the item it depends on fails or is skipped (unless cascade_skip is set to False on that item). See Selectors for a complete overview of the ways to specify items here. needed_by This attribute is an alternative way of defining dependencies. It works just like needs , but in the other direction. There are only three scenarios where you should use needed_by over needs : if you need all items of a certain type to depend on something or if you need all items in a bundle to depend on something or if you need an item in a bundle you can't edit to depend on something in your bundles tags A list of strings to tag an item with. Tagging has no immediate effect in itself, but can be useful in a number of places. For example, you can add dependencies on all items with a given tag: pkg_apt = { \"mysql-server-{}\".format(node.metadata.get('mysql_version', \"5.5\")): { 'tags': [\"provides-mysqld\"], }, } svc_systemd = { \"myapp\": { 'needs': [\"tag:provides-mysqld\"], }, } In this simplified example we save ourselves from duplicating the logic that gets the current MySQL version from metadata (which is probably overkill here, but you might encounter more complex situations). Tags also allow for optional dependencies, since items can depend on tags that don't exist. So for example if you need to do something after items from another bundle have been completed, but that bundle might not always be there, you can depend on a tag given to the items of the other bundle. triggers and triggered In some scenarios, you may want to execute an action only when an item is fixed (e.g. restart a daemon after a config file has changed or run postmap after updating an alias file). To do this, BundleWrap has the builtin atttribute triggers . You can use it to point to any item that has its triggered attribute set to True . Such items will only be checked (or in the case of actions: run) if the triggering item is fixed (or a triggering action completes successfully). files = { '/etc/daemon.conf': { [...] 'triggers': [ 'action:restart_daemon', ], }, } actions = { 'restart_daemon': { 'command': \"service daemon restart\", 'triggered': True, }, } The above example will run service daemon restart every time BundleWrap successfully applies a change to /etc/daemon.conf . If an action is triggered multiple times, it will only be run once. Similar to needed_by , triggered_by can be used to define a triggers relationship from the opposite direction. See Selectors for a complete overview of the ways to specify items here. preceded_by Operates like triggers , but will apply the triggered item before the triggering item. Let's look at an example: files = { '/etc/example.conf': { [...] 'preceded_by': [ 'action:backup_example', ], }, } actions = { 'backup_example': { 'command': \"cp /etc/example.conf /etc/example.conf.bak\", 'triggered': True, }, } In this configuration, /etc/example.conf will always be copied before and only if it is changed. You would probably also want to set cascade_skip to False on the action so you can skip it in interactive mode when you're sure you don't need the backup copy. Similar to needed_by , precedes can be used to define a preceded_by relationship from the opposite direction. See Selectors for a complete overview of the ways to specify items here. skip Set this to True to always skip this item. This is useful if you just want to quickly disable this item to try something or if it's sitting somewhere in a dependency chain and it would be too cumbersome to remove entirely under certain conditions. Note that setting this to True will also change the default for cascade_skip to False . unless Another builtin item attribute is unless . For example, it can be used to construct a one-off file item where BundleWrap will only create the file once, but won't check or modify its contents once it exists. files = { \"/path/to/file\": { [...] \"unless\": \"test -x /path/to/file\", }, } This will run test -x /path/to/file before doing anything with the item. If the command returns 0, no action will be taken to \"correct\" the item. Another common use for unless is with actions that perform some sort of install operation. In this case, the unless condition makes sure the install operation is only performed when it is needed instead of every time you run bw apply . In scenarios like this you will probably want to set cascade_skip to False so that skipping the installation (because the thing is already installed) will not cause every item that depends on the installed thing to be skipped. Example: actions = { 'download_thing': { 'command': \"wget http://example.com/thing.bin -O /opt/thing.bin && chmod +x /opt/thing.bin\", 'unless': \"test -x /opt/thing.bin\", 'cascade_skip': False, }, 'run_thing': { 'command': \"/opt/thing.bin\", 'needs': [\"action:download_thing\"], }, } If action:download_thing would not set cascade_skip to False , action:run_thing would only be executed once: directly after the thing has been downloaded. On subsequent runs, action:download_thing will fail the unless condition and be skipped. This would also cause all items that depend on it to be skipped, including action:run_thing . The commands you choose for unless should not change the state of your node. Otherwise, running bw verify might unexpectedly interfere with your nodes. cascade_skip DEPRECATED: Use before and after instead. There are some situations where you don't want to default behavior of skipping everything that depends on a skipped item. That's where cascade_skip comes in. Set it to False and skipping an item won't skip those that depend on it. Note that items can be skipped interactively or because of bw apply --only or bw apply --skip or because a Fault was unavailable or they were soft-locked on the node or because they haven't been triggered or because one of their dependencies was skipped or because one of their dependencies failed or they failed their unless condition or the skip attribute was set or because an action had its interactive attribute set to True during a non-interactive run The following example will offer to run an apt-get update before installing a package, but continue to install the package even if the update is declined interactively. actions = { 'apt_update': { 'cascade_skip': False, 'command': \"apt-get update\", }, } pkg_apt = { 'somepkg': { 'needs': [\"action:apt_update\"], }, } cascade_skip defaults to True . However, if the item uses the unless or skip attributes or is triggered, the default changes to False . Most of the time, this is what you'll want. when_creating These attributes are only enforced during the creation of the item on the node (this means the first run of bw apply after adding this item to config). They are ignored in subsequent runs of bw apply , and when other (non-when_creating) attributes are changed. Canned actions Some item types have what we call \"canned actions\". Those are pre-defined actions attached directly to an item. Take a look at this example: svc_upstart = {'mysql': {'running': True}} files = { \"/etc/mysql/my.cnf\": { 'source': \"my.cnf\", 'triggers': [ \"svc_upstart:mysql:reload\", # this triggers the canned action ], }, } Canned actions always have to be triggered in order to run. In the example above, a change in the file /etc/mysql/my.cnf will trigger the reload action defined by the svc_upstart item type for the mysql service.","title":"bundles/.../items.py"},{"location":"repo/items.py/#item-types","text":"This table lists all item types included in BundleWrap along with the bundle attributes they understand. Type Bundle attribute Description action actions Actions allow you to run commands on every bw apply directory directories Manages permissions and ownership for directories file files Manages contents, permissions, and ownership for files git_deploy git_deploy Deploys the contents of a git repository group groups Manages groups by wrapping groupadd , groupmod and groupdel k8s_* k8s_* Manages resources in Kubernetes clusters by wrapping kubectl pkg_apt pkg_apt Installs and removes packages with APT pkg_dnf pkg_dnf Installs and removes packages with dnf pkg_opkg pkg_opkg Installs and removes packages with opkg pkg_pacman pkg_pacman Installs and removes packages with pacman pkg_pamac pkg_pamac Installs and removes packages with pamac pkg_pip pkg_pip Installs and removes Python packages with pip pkg_snap pkg_snap Installs and removes packages with snap pkg_yum pkg_yum Installs and removes packages with yum pkg_zypper pkg_zypper Installs and removes packages with zypper postgres_db postgres_dbs Manages Postgres databases postgres_role postgres_roles Manages Postgres roles pkg_pip pkg_pip Installs and removes Python packages with pip pkg_freebsd pkg_freebsd Installs and removes FreeBSD packages with pkg pkg_openbsd pkg_openbsd Installs and removes OpenBSD packages with pkg_add/pkg_delete routeros routeros Manages RouterOS configuration svc_freebsd svc_freebsd Starts and stops services with FreeBSD's rc svc_openbsd svc_openbsd Starts and stops services with OpenBSD's rc svc_systemd svc_systemd Starts and stops services with systemd svc_systemv svc_systemv Starts and stops services with traditional System V init scripts svc_upstart svc_upstart Starts and stops services with Upstart symlink symlinks Manages symbolic links and their ownership user users Manages users by wrapping useradd , usermod and userdel zfs_dataset zfs_datasets Manages ZFS datasets zfs_pool zfs_pools Manages ZFS pools","title":"Item types"},{"location":"repo/items.py/#builtin-item-attributes","text":"There are also attributes that can be applied to any kind of item.","title":"Builtin item attributes"},{"location":"repo/items.py/#after","text":"This lets you control execution order of items. This is not something you will have to do very often, because there are already implicit dependencies between item types (e.g. all files automatically depend on the users owning them). actions = { 'a': { 'command': 'true', }, 'b': { 'command': 'true', 'after': {'action:a'}, }, } When set up like this, action:b will only run after action:a has been completed. Note that it doesn't matter if action:a is successful or not, that what needs is for. See Selectors for a complete overview of the ways to specify items here.","title":"after"},{"location":"repo/items.py/#before","text":"Just like after , but in the opposite direction.","title":"before"},{"location":"repo/items.py/#comment","text":"This is a string that will be displayed in interactive mode ( bw apply -i ) whenever the item is to be changed in any way. You can use it to warn users before they start disruptive actions.","title":"comment"},{"location":"repo/items.py/#error_on_missing_fault","text":"This will simply skip an item instead of raising an error when a Fault used for an attribute on the item is unavailable. Faults are special objects used by repo.vault to handle secrets . A Fault being unavailable can mean you're missing the secret key required to decrypt a secret you're trying to use as an item attribute value. Defaults to False .","title":"error_on_missing_fault"},{"location":"repo/items.py/#needs","text":"This allows for setting up dependencies between items. Here are two examples: my_items = { 'item1': { [...] 'needs': [ 'file:/etc/foo.conf', ], }, 'item2': { [...] 'needs': [ 'pkg_apt:', 'bundle:foo', ], } } The first item ( item1 , specific attributes have been omitted) depends on a file called /etc/foo.conf , while item2 depends on all APT packages being installed and every item in the foo bundle. Note that unlike after , with needs the depending item will be skipped if the item it depends on fails or is skipped (unless cascade_skip is set to False on that item). See Selectors for a complete overview of the ways to specify items here.","title":"needs"},{"location":"repo/items.py/#needed_by","text":"This attribute is an alternative way of defining dependencies. It works just like needs , but in the other direction. There are only three scenarios where you should use needed_by over needs : if you need all items of a certain type to depend on something or if you need all items in a bundle to depend on something or if you need an item in a bundle you can't edit to depend on something in your bundles","title":"needed_by"},{"location":"repo/items.py/#tags","text":"A list of strings to tag an item with. Tagging has no immediate effect in itself, but can be useful in a number of places. For example, you can add dependencies on all items with a given tag: pkg_apt = { \"mysql-server-{}\".format(node.metadata.get('mysql_version', \"5.5\")): { 'tags': [\"provides-mysqld\"], }, } svc_systemd = { \"myapp\": { 'needs': [\"tag:provides-mysqld\"], }, } In this simplified example we save ourselves from duplicating the logic that gets the current MySQL version from metadata (which is probably overkill here, but you might encounter more complex situations). Tags also allow for optional dependencies, since items can depend on tags that don't exist. So for example if you need to do something after items from another bundle have been completed, but that bundle might not always be there, you can depend on a tag given to the items of the other bundle.","title":"tags"},{"location":"repo/items.py/#triggers-and-triggered","text":"In some scenarios, you may want to execute an action only when an item is fixed (e.g. restart a daemon after a config file has changed or run postmap after updating an alias file). To do this, BundleWrap has the builtin atttribute triggers . You can use it to point to any item that has its triggered attribute set to True . Such items will only be checked (or in the case of actions: run) if the triggering item is fixed (or a triggering action completes successfully). files = { '/etc/daemon.conf': { [...] 'triggers': [ 'action:restart_daemon', ], }, } actions = { 'restart_daemon': { 'command': \"service daemon restart\", 'triggered': True, }, } The above example will run service daemon restart every time BundleWrap successfully applies a change to /etc/daemon.conf . If an action is triggered multiple times, it will only be run once. Similar to needed_by , triggered_by can be used to define a triggers relationship from the opposite direction. See Selectors for a complete overview of the ways to specify items here.","title":"triggers and triggered"},{"location":"repo/items.py/#preceded_by","text":"Operates like triggers , but will apply the triggered item before the triggering item. Let's look at an example: files = { '/etc/example.conf': { [...] 'preceded_by': [ 'action:backup_example', ], }, } actions = { 'backup_example': { 'command': \"cp /etc/example.conf /etc/example.conf.bak\", 'triggered': True, }, } In this configuration, /etc/example.conf will always be copied before and only if it is changed. You would probably also want to set cascade_skip to False on the action so you can skip it in interactive mode when you're sure you don't need the backup copy. Similar to needed_by , precedes can be used to define a preceded_by relationship from the opposite direction. See Selectors for a complete overview of the ways to specify items here.","title":"preceded_by"},{"location":"repo/items.py/#skip","text":"Set this to True to always skip this item. This is useful if you just want to quickly disable this item to try something or if it's sitting somewhere in a dependency chain and it would be too cumbersome to remove entirely under certain conditions. Note that setting this to True will also change the default for cascade_skip to False .","title":"skip"},{"location":"repo/items.py/#unless","text":"Another builtin item attribute is unless . For example, it can be used to construct a one-off file item where BundleWrap will only create the file once, but won't check or modify its contents once it exists. files = { \"/path/to/file\": { [...] \"unless\": \"test -x /path/to/file\", }, } This will run test -x /path/to/file before doing anything with the item. If the command returns 0, no action will be taken to \"correct\" the item. Another common use for unless is with actions that perform some sort of install operation. In this case, the unless condition makes sure the install operation is only performed when it is needed instead of every time you run bw apply . In scenarios like this you will probably want to set cascade_skip to False so that skipping the installation (because the thing is already installed) will not cause every item that depends on the installed thing to be skipped. Example: actions = { 'download_thing': { 'command': \"wget http://example.com/thing.bin -O /opt/thing.bin && chmod +x /opt/thing.bin\", 'unless': \"test -x /opt/thing.bin\", 'cascade_skip': False, }, 'run_thing': { 'command': \"/opt/thing.bin\", 'needs': [\"action:download_thing\"], }, } If action:download_thing would not set cascade_skip to False , action:run_thing would only be executed once: directly after the thing has been downloaded. On subsequent runs, action:download_thing will fail the unless condition and be skipped. This would also cause all items that depend on it to be skipped, including action:run_thing . The commands you choose for unless should not change the state of your node. Otherwise, running bw verify might unexpectedly interfere with your nodes.","title":"unless"},{"location":"repo/items.py/#cascade_skip","text":"DEPRECATED: Use before and after instead. There are some situations where you don't want to default behavior of skipping everything that depends on a skipped item. That's where cascade_skip comes in. Set it to False and skipping an item won't skip those that depend on it. Note that items can be skipped interactively or because of bw apply --only or bw apply --skip or because a Fault was unavailable or they were soft-locked on the node or because they haven't been triggered or because one of their dependencies was skipped or because one of their dependencies failed or they failed their unless condition or the skip attribute was set or because an action had its interactive attribute set to True during a non-interactive run The following example will offer to run an apt-get update before installing a package, but continue to install the package even if the update is declined interactively. actions = { 'apt_update': { 'cascade_skip': False, 'command': \"apt-get update\", }, } pkg_apt = { 'somepkg': { 'needs': [\"action:apt_update\"], }, } cascade_skip defaults to True . However, if the item uses the unless or skip attributes or is triggered, the default changes to False . Most of the time, this is what you'll want.","title":"cascade_skip"},{"location":"repo/items.py/#when_creating","text":"These attributes are only enforced during the creation of the item on the node (this means the first run of bw apply after adding this item to config). They are ignored in subsequent runs of bw apply , and when other (non-when_creating) attributes are changed.","title":"when_creating"},{"location":"repo/items.py/#canned-actions","text":"Some item types have what we call \"canned actions\". Those are pre-defined actions attached directly to an item. Take a look at this example: svc_upstart = {'mysql': {'running': True}} files = { \"/etc/mysql/my.cnf\": { 'source': \"my.cnf\", 'triggers': [ \"svc_upstart:mysql:reload\", # this triggers the canned action ], }, } Canned actions always have to be triggered in order to run. In the example above, a change in the file /etc/mysql/my.cnf will trigger the reload action defined by the svc_upstart item type for the mysql service.","title":"Canned actions"},{"location":"repo/layout/","text":".bs-sidebar { display: none; } Repository layout A BundleWrap repository contains everything you need to contruct the configuration for your systems. This page describes the various subdirectories and files than can exist inside a repo. nodes.py This file tells BundleWrap what nodes (servers, VMs, ...) there are in your environment and lets you configure options such as hostnames. groups.py This file allows you to organize your nodes into groups. bundles/ This required subdirectory contains the bulk of your configuration, organized into bundles of related items. Each bundle is a subdirectory of bundles/ with an items.py or metadata.py in it (or both). data/ This optional subdirectory contains data files that are not generic enough to be included in bundles (which are meant to be shareable). hooks/ This optional subdirectory contains hooks you can use to act on certain events when using BundleWrap. items/ This optional subdirectory contains the code for your custom item types. libs/ This optional subdirectory contains reusable custom code for your bundles.","title":"Overview"},{"location":"repo/layout/#repository-layout","text":"A BundleWrap repository contains everything you need to contruct the configuration for your systems. This page describes the various subdirectories and files than can exist inside a repo. nodes.py This file tells BundleWrap what nodes (servers, VMs, ...) there are in your environment and lets you configure options such as hostnames. groups.py This file allows you to organize your nodes into groups. bundles/ This required subdirectory contains the bulk of your configuration, organized into bundles of related items. Each bundle is a subdirectory of bundles/ with an items.py or metadata.py in it (or both). data/ This optional subdirectory contains data files that are not generic enough to be included in bundles (which are meant to be shareable). hooks/ This optional subdirectory contains hooks you can use to act on certain events when using BundleWrap. items/ This optional subdirectory contains the code for your custom item types. libs/ This optional subdirectory contains reusable custom code for your bundles.","title":"Repository layout"},{"location":"repo/libs/","text":".bs-sidebar { display: none; } Custom code The libs/ subdirectory of your repository provides a convenient place to put reusable code used throughout your bundles and hooks. A Python module called example.py placed in this directory will be available as repo.libs.example wherever you have access to a bundlewrap.repo.Repository object. In nodes.py and groups.py , you can do the same thing with just libs.example . Only single files, no subdirectories or packages, are supported at the moment.","title":"libs/"},{"location":"repo/libs/#custom-code","text":"The libs/ subdirectory of your repository provides a convenient place to put reusable code used throughout your bundles and hooks. A Python module called example.py placed in this directory will be available as repo.libs.example wherever you have access to a bundlewrap.repo.Repository object. In nodes.py and groups.py , you can do the same thing with just libs.example . Only single files, no subdirectories or packages, are supported at the moment.","title":"Custom code"},{"location":"repo/metadata.py/","text":"metadata.py Alongside items.py you may create another file called metadata.py . It can be used to define defaults and do advanced processing of the metadata you configured for your nodes and groups. Specifically, it allows each bundle to modify metadata before items.py is evaluated. Defaults Let's look at defaults first: defaults = { \"foo\": 5, } This will simply ensure that the \"foo\" key in metadata will always be set, but the default value of 5 can be overridden by node or group metadata or metadata reactors. Reactors So let's look at reactors next. Metadata reactors are functions that take the metadata generated for this node so far as their single argument. You must then return a new dictionary with any metadata you wish to have added: @metadata_reactor def bar(metadata): return { \"bar\": metadata.get(\"foo\"), } While this looks simple enough, there are some important caveats. First and foremost: Metadata reactors must assume to be called many times. This is to give you an opportunity to react to metadata provided by other reactors. All reactors will be run again and again until none of them return any changed metadata. Anything you return from a reactor will overwrite defaults, while metadata from groups.py and nodes.py will still overwrite metadata from reactors. Collection types like sets and dicts will be merged. The parameter metadata is not a dictionary but an instance of an opaque type, which resembles a dict in some ways. You cannot modify the contents of this object. It provides .get(\"some/path\", \"default\") to query a key path (equivalent to metadata[\"some\"][\"path\"] in a dict) and accepts an optional default value. It will raise a KeyError when called for a non-existant path without a default. While node and group metadata and metadata defaults will always be available to reactors, you should not rely on that for the simple reason that you may one day move some metadata from those static sources into another reactor, which may be run later. Thus you may need to wait for some iterations before that data shows up in metadata . Note that BundleWrap will catch any KeyError s raised in metadata reactors and only report them if they don't go away after all other relevant reactors are done. You can also access other nodes' metadata: @metadata_reactor def baz(metadata): frob = set() for n in repo.nodes: frob.add(n.metadata.get('sizzle')) return {'frob': frob} A performance optimization: metadata_reactor.provides If you have lots of metadata reactors, performance can become an issue. Every time you access metadata (e.g., in items.py or templates), BundleWrap has to find the value for that metadata key. This requires running metadata reactors. The problem here is that \u2013 without further help \u2013 BundleWrap does not know which reactors to run, so it runs them all, which can be costly. To help BundleWrap optimize this process, you can annotate your reactors. Take the reactor from above, for example: @metadata_reactor.provides( 'frob', ) def baz(metadata): frob = set() for n in repo.nodes: frob.add(n.metadata.get('sizzle')) return {'frob': frob} Now BundleWrap knows that, in order to calculate the value of the frob key, it has to run this reactor. By annotating all of your reactors, BundleWrap can know exactly which ones to run. Here are some more examples of specifying metadata keys: @metadata_reactor.provides( 'frob', 'foo/bar', ('quz', 'irritating/slashes'), ) def baz(metadata): # ... do something ... return { 'frob': frob, 'foo': { 'bar': bar_result, }, 'quz': { 'irritating/slashes': some_value, }, } So, when a metadata key contains slashes, you have to use a tuple. DoNotRunAgain On the other hand, if your reactor only needs to provide new metadata in some cases, you can tell BundleWrap to not run it again to save some performance: @metadata_reactor def foo(metadata): if node.has_bundle(\"bar\"): return {\"bar\": metadata.get(\"foo\") + 1} else: raise DoNotRunAgain For your convenience, you can access repo , node , metadata_reactor , and DoNotRunAgain in metadata.py without importing them. Priority For atomic (\"primitive\") data types like int or bool : Nodes Groups Reactors Defaults Node metadata wins over group metadata, groups win over reactors, reactors win over defaults. This also applies to type conflicts: For example, specifying a boolean flag in node metadata will win over a list returned by a metadata reactor. (You should probably avoid situations like this entirely.) Set-like data types will be merged recursively. Also see the documentation for node.metadata and group.metadata for more information.","title":"bundles/.../metadata.py"},{"location":"repo/metadata.py/#metadatapy","text":"Alongside items.py you may create another file called metadata.py . It can be used to define defaults and do advanced processing of the metadata you configured for your nodes and groups. Specifically, it allows each bundle to modify metadata before items.py is evaluated.","title":"metadata.py"},{"location":"repo/metadata.py/#defaults","text":"Let's look at defaults first: defaults = { \"foo\": 5, } This will simply ensure that the \"foo\" key in metadata will always be set, but the default value of 5 can be overridden by node or group metadata or metadata reactors.","title":"Defaults"},{"location":"repo/metadata.py/#reactors","text":"So let's look at reactors next. Metadata reactors are functions that take the metadata generated for this node so far as their single argument. You must then return a new dictionary with any metadata you wish to have added: @metadata_reactor def bar(metadata): return { \"bar\": metadata.get(\"foo\"), } While this looks simple enough, there are some important caveats. First and foremost: Metadata reactors must assume to be called many times. This is to give you an opportunity to react to metadata provided by other reactors. All reactors will be run again and again until none of them return any changed metadata. Anything you return from a reactor will overwrite defaults, while metadata from groups.py and nodes.py will still overwrite metadata from reactors. Collection types like sets and dicts will be merged. The parameter metadata is not a dictionary but an instance of an opaque type, which resembles a dict in some ways. You cannot modify the contents of this object. It provides .get(\"some/path\", \"default\") to query a key path (equivalent to metadata[\"some\"][\"path\"] in a dict) and accepts an optional default value. It will raise a KeyError when called for a non-existant path without a default. While node and group metadata and metadata defaults will always be available to reactors, you should not rely on that for the simple reason that you may one day move some metadata from those static sources into another reactor, which may be run later. Thus you may need to wait for some iterations before that data shows up in metadata . Note that BundleWrap will catch any KeyError s raised in metadata reactors and only report them if they don't go away after all other relevant reactors are done. You can also access other nodes' metadata: @metadata_reactor def baz(metadata): frob = set() for n in repo.nodes: frob.add(n.metadata.get('sizzle')) return {'frob': frob}","title":"Reactors"},{"location":"repo/metadata.py/#a-performance-optimization-metadata_reactorprovides","text":"If you have lots of metadata reactors, performance can become an issue. Every time you access metadata (e.g., in items.py or templates), BundleWrap has to find the value for that metadata key. This requires running metadata reactors. The problem here is that \u2013 without further help \u2013 BundleWrap does not know which reactors to run, so it runs them all, which can be costly. To help BundleWrap optimize this process, you can annotate your reactors. Take the reactor from above, for example: @metadata_reactor.provides( 'frob', ) def baz(metadata): frob = set() for n in repo.nodes: frob.add(n.metadata.get('sizzle')) return {'frob': frob} Now BundleWrap knows that, in order to calculate the value of the frob key, it has to run this reactor. By annotating all of your reactors, BundleWrap can know exactly which ones to run. Here are some more examples of specifying metadata keys: @metadata_reactor.provides( 'frob', 'foo/bar', ('quz', 'irritating/slashes'), ) def baz(metadata): # ... do something ... return { 'frob': frob, 'foo': { 'bar': bar_result, }, 'quz': { 'irritating/slashes': some_value, }, } So, when a metadata key contains slashes, you have to use a tuple.","title":"A performance optimization: metadata_reactor.provides"},{"location":"repo/metadata.py/#donotrunagain","text":"On the other hand, if your reactor only needs to provide new metadata in some cases, you can tell BundleWrap to not run it again to save some performance: @metadata_reactor def foo(metadata): if node.has_bundle(\"bar\"): return {\"bar\": metadata.get(\"foo\") + 1} else: raise DoNotRunAgain For your convenience, you can access repo , node , metadata_reactor , and DoNotRunAgain in metadata.py without importing them.","title":"DoNotRunAgain"},{"location":"repo/metadata.py/#priority","text":"For atomic (\"primitive\") data types like int or bool : Nodes Groups Reactors Defaults Node metadata wins over group metadata, groups win over reactors, reactors win over defaults. This also applies to type conflicts: For example, specifying a boolean flag in node metadata will win over a list returned by a metadata reactor. (You should probably avoid situations like this entirely.) Set-like data types will be merged recursively. Also see the documentation for node.metadata and group.metadata for more information.","title":"Priority"},{"location":"repo/nodes.py/","text":"nodes.py This file lets you specify or dynamically build a list of nodes in your environment. All you have to do here is define a Python dictionary called nodes . It should look something like this: nodes = { \"node-1\": { 'hostname': \"node-1.example.com\", }, } With BundleWrap, the DNS name and the internal identifier for a node (\"node-1\" in this case) are two separate things. All fields for a node (including hostname ) are optional. If you don't give one, BundleWrap will attempt to use the internal identifier to connect to a node: nodes = { \"node-1.example.com\": {}, } Dynamic node list You are not confined to the static way of defining a node list as shown above. You can also assemble the nodes dictionary dynamically: def get_my_nodes_from_ldap(): [...] return ldap_nodes nodes = get_my_nodes_from_ldap() One file per node Especially in larger installations, a single nodes.py can become inconvenient to work with. This example reads nodes from a nodes/ directory. from glob import glob from os.path import join nodes = {} for node in glob(join(repo_path, \"nodes\", \"*.py\")): with open(node, 'r') as f: exec(f.read()) Node files would then append nodes , like this: # nodes/node-1.py nodes['node-1'] = { 'hostname': \"node-1.example.com\", } Alternatively, consider using TOML nodes . Node attribute reference This section is a reference for all possible attributes you can define for a node: nodes = { 'node-1': { # THIS PART IS EXPLAINED HERE }, } All attributes can also be set at the group level, unless noted otherwise. Regular attributes bundles A list of bundle names to be assigned to this node. Bundles set at group level will be added. dummy Set this to True to prevent BundleWrap from creating items for and connecting to this node. This is useful for unmanaged nodes because you can still assign them bundles and metadata like regular nodes and access that from managed nodes (e.g. for monitoring). groups A list of group names this node should be added to. Be aware that you can also define group members at the group itself and you probably should not use both methods in parallel to avoid confusion. Cannot be set at group level. hostname A string used as a DNS name when connecting to this node. May also be an IP address. The username and SSH private key for connecting to the node cannot be configured in BundleWrap. If you need to customize those, BundleWrap will honor your ~/.ssh/config . Cannot be set at group level. ipmi_hostname, ipmi_username, ipmi_password, ipmi_interface A dictionary defining the nodes ipmi connection (if available). Will only be used with bw ipmi commands. Using ipmi_interface is optional and will default to whatever ipmitool uses as default. See ipmitool --help for possible options. metadata This can be a dictionary of arbitrary data (some type restrictions apply). You can access it from your templates as node.metadata . Use this to attach custom data (such as a list of IP addresses that should be configured on the target node) to the node. Note that you can also define metadata at the group level , but node metadata has higher priority. You are restricted to using only the following types in metadata: dict list tuple set bool text / unicode bytes / str (only if decodable into text using UTF-8) int None bundlewrap.utils.Fault Also see the documentation for group.metadata and metadata.py for more information. os Defaults to \"linux\" . A list of supported OSes can be obtained with bw debug -n ANY_NODE_NAME -c \"print(node.OS_KNOWN)\" . os_version Set this to your OS version. Note that it must be a tuple of integers, e.g. if you're running Ubuntu 16.04 LTS, it should be (16, 4) . Tuples of integers can be used for easy comparison of versions: (12, 4) < (16, 4) password Which password to use when connecting to the node. Currently only supported for RouterOS. username Which username to use when connecting to the node. Leave this unset to use SSH configuration instead (recommended). OS compatibility overrides cmd_wrapper_outer Used whenever a command needs to be run on a node. Defaults to \"sudo sh -c {}\" . {} will be replaced by the quoted command to be run (after cmd_wrapper_inner has been applied). You will need to override this if you're not using sudo to gain root privileges (e.g. doas ) on the node. cmd_wrapper_inner Used whenever a command needs to be run on a node. Defaults to \"export LANG=C; {}\" . {} will be replaced by the command to be run. You will need to override this if the shell on your node sets environment variables differently. lock_dir Directory that will be used for creating locks on the node. Defaults to \"/var/lib/bundlewrap\" . Will be created if it does not exist. You will need to override this if /var/lib is restricted somehow on your node (SElinux, mounted readonly, etc.). pip_command This setting will affect how pkg_pip will behave. By default, it will use whatever pip on your system defaults to. You will need to override this if you don't have pip , but (for example) only pip3 . Be aware that this setting has no effect when using virtualenvs. use_shadow_passwords Changing this setting will affect the security of the target system. Only do this for legacy systems that don't support shadow passwords. This setting will affect how the user item item operates. If set to False , password hashes will be written directly to /etc/passwd and thus be accessible to any user on the system. If the OS of the node is set to \"openbsd\", this setting has no effect as master.shadow is always used. Dynamic node attributes You can define callbacks that will act as read-only node attributes at runtime. For example: @node_attribute def uptime(node): return node.run(\"uptime\").stdout.decode().strip() After adding this to your nodes.py , you can then get an overview of all your uptimes using bw nodes -a uptime or make use of node.uptime in your bundles and other places where you have access to node objects. Be mindful when using this feature: The primary intended purpose of this is usage with bw nodes -a (so you can see builtin attributes, metadata, and node.run() results in a single table). It is not recommended that you derive configuration from these attributes if they're using node.run() . Doing so will make bw test dependent on node access and availability, while also making bw hash non-deterministic.","title":"nodes.py"},{"location":"repo/nodes.py/#nodespy","text":"This file lets you specify or dynamically build a list of nodes in your environment. All you have to do here is define a Python dictionary called nodes . It should look something like this: nodes = { \"node-1\": { 'hostname': \"node-1.example.com\", }, } With BundleWrap, the DNS name and the internal identifier for a node (\"node-1\" in this case) are two separate things. All fields for a node (including hostname ) are optional. If you don't give one, BundleWrap will attempt to use the internal identifier to connect to a node: nodes = { \"node-1.example.com\": {}, }","title":"nodes.py"},{"location":"repo/nodes.py/#dynamic-node-list","text":"You are not confined to the static way of defining a node list as shown above. You can also assemble the nodes dictionary dynamically: def get_my_nodes_from_ldap(): [...] return ldap_nodes nodes = get_my_nodes_from_ldap()","title":"Dynamic node list"},{"location":"repo/nodes.py/#one-file-per-node","text":"Especially in larger installations, a single nodes.py can become inconvenient to work with. This example reads nodes from a nodes/ directory. from glob import glob from os.path import join nodes = {} for node in glob(join(repo_path, \"nodes\", \"*.py\")): with open(node, 'r') as f: exec(f.read()) Node files would then append nodes , like this: # nodes/node-1.py nodes['node-1'] = { 'hostname': \"node-1.example.com\", } Alternatively, consider using TOML nodes .","title":"One file per node"},{"location":"repo/nodes.py/#node-attribute-reference","text":"This section is a reference for all possible attributes you can define for a node: nodes = { 'node-1': { # THIS PART IS EXPLAINED HERE }, } All attributes can also be set at the group level, unless noted otherwise.","title":"Node attribute reference"},{"location":"repo/nodes.py/#regular-attributes","text":"","title":"Regular attributes"},{"location":"repo/nodes.py/#bundles","text":"A list of bundle names to be assigned to this node. Bundles set at group level will be added.","title":"bundles"},{"location":"repo/nodes.py/#dummy","text":"Set this to True to prevent BundleWrap from creating items for and connecting to this node. This is useful for unmanaged nodes because you can still assign them bundles and metadata like regular nodes and access that from managed nodes (e.g. for monitoring).","title":"dummy"},{"location":"repo/nodes.py/#groups","text":"A list of group names this node should be added to. Be aware that you can also define group members at the group itself and you probably should not use both methods in parallel to avoid confusion. Cannot be set at group level.","title":"groups"},{"location":"repo/nodes.py/#hostname","text":"A string used as a DNS name when connecting to this node. May also be an IP address. The username and SSH private key for connecting to the node cannot be configured in BundleWrap. If you need to customize those, BundleWrap will honor your ~/.ssh/config . Cannot be set at group level.","title":"hostname"},{"location":"repo/nodes.py/#ipmi_hostname-ipmi_username-ipmi_password-ipmi_interface","text":"A dictionary defining the nodes ipmi connection (if available). Will only be used with bw ipmi commands. Using ipmi_interface is optional and will default to whatever ipmitool uses as default. See ipmitool --help for possible options.","title":"ipmi_hostname, ipmi_username, ipmi_password, ipmi_interface"},{"location":"repo/nodes.py/#metadata","text":"This can be a dictionary of arbitrary data (some type restrictions apply). You can access it from your templates as node.metadata . Use this to attach custom data (such as a list of IP addresses that should be configured on the target node) to the node. Note that you can also define metadata at the group level , but node metadata has higher priority. You are restricted to using only the following types in metadata: dict list tuple set bool text / unicode bytes / str (only if decodable into text using UTF-8) int None bundlewrap.utils.Fault Also see the documentation for group.metadata and metadata.py for more information.","title":"metadata"},{"location":"repo/nodes.py/#os","text":"Defaults to \"linux\" . A list of supported OSes can be obtained with bw debug -n ANY_NODE_NAME -c \"print(node.OS_KNOWN)\" .","title":"os"},{"location":"repo/nodes.py/#os_version","text":"Set this to your OS version. Note that it must be a tuple of integers, e.g. if you're running Ubuntu 16.04 LTS, it should be (16, 4) . Tuples of integers can be used for easy comparison of versions: (12, 4) < (16, 4)","title":"os_version"},{"location":"repo/nodes.py/#password","text":"Which password to use when connecting to the node. Currently only supported for RouterOS.","title":"password"},{"location":"repo/nodes.py/#username","text":"Which username to use when connecting to the node. Leave this unset to use SSH configuration instead (recommended).","title":"username"},{"location":"repo/nodes.py/#os-compatibility-overrides","text":"","title":"OS compatibility overrides"},{"location":"repo/nodes.py/#cmd_wrapper_outer","text":"Used whenever a command needs to be run on a node. Defaults to \"sudo sh -c {}\" . {} will be replaced by the quoted command to be run (after cmd_wrapper_inner has been applied). You will need to override this if you're not using sudo to gain root privileges (e.g. doas ) on the node.","title":"cmd_wrapper_outer"},{"location":"repo/nodes.py/#cmd_wrapper_inner","text":"Used whenever a command needs to be run on a node. Defaults to \"export LANG=C; {}\" . {} will be replaced by the command to be run. You will need to override this if the shell on your node sets environment variables differently.","title":"cmd_wrapper_inner"},{"location":"repo/nodes.py/#lock_dir","text":"Directory that will be used for creating locks on the node. Defaults to \"/var/lib/bundlewrap\" . Will be created if it does not exist. You will need to override this if /var/lib is restricted somehow on your node (SElinux, mounted readonly, etc.).","title":"lock_dir"},{"location":"repo/nodes.py/#pip_command","text":"This setting will affect how pkg_pip will behave. By default, it will use whatever pip on your system defaults to. You will need to override this if you don't have pip , but (for example) only pip3 . Be aware that this setting has no effect when using virtualenvs.","title":"pip_command"},{"location":"repo/nodes.py/#use_shadow_passwords","text":"Changing this setting will affect the security of the target system. Only do this for legacy systems that don't support shadow passwords. This setting will affect how the user item item operates. If set to False , password hashes will be written directly to /etc/passwd and thus be accessible to any user on the system. If the OS of the node is set to \"openbsd\", this setting has no effect as master.shadow is always used.","title":"use_shadow_passwords"},{"location":"repo/nodes.py/#dynamic-node-attributes","text":"You can define callbacks that will act as read-only node attributes at runtime. For example: @node_attribute def uptime(node): return node.run(\"uptime\").stdout.decode().strip() After adding this to your nodes.py , you can then get an overview of all your uptimes using bw nodes -a uptime or make use of node.uptime in your bundles and other places where you have access to node objects. Be mindful when using this feature: The primary intended purpose of this is usage with bw nodes -a (so you can see builtin attributes, metadata, and node.run() results in a single table). It is not recommended that you derive configuration from these attributes if they're using node.run() . Doing so will make bw test dependent on node access and availability, while also making bw hash non-deterministic.","title":"Dynamic node attributes"},{"location":"repo/requirements.txt/","text":".bs-sidebar { display: none; } requirements.txt This optional file can be used to ensure minimum required versions of BundleWrap and other Python packages on every machine that uses a repository. bw repo create will initially add your current version of BundleWrap: bundlewrap>=2.4.0 You can add more packages as you like (you do not have to specify a version for each one), just append each package in a separate line. When someone then tries to use your repo without one of those packages, BundleWrap will exit early with a friendly error message: ! Python package 'foo' is listed in requirements.txt, but wasn't found. You probably have to install it with `pip install foo`.","title":"requirements.txt"},{"location":"repo/requirements.txt/#requirementstxt","text":"This optional file can be used to ensure minimum required versions of BundleWrap and other Python packages on every machine that uses a repository. bw repo create will initially add your current version of BundleWrap: bundlewrap>=2.4.0 You can add more packages as you like (you do not have to specify a version for each one), just append each package in a separate line. When someone then tries to use your repo without one of those packages, BundleWrap will exit early with a friendly error message: ! Python package 'foo' is listed in requirements.txt, but wasn't found. You probably have to install it with `pip install foo`.","title":"requirements.txt"}]}